{"pages":[],"posts":[{"title":"React Native 组件生命周期学习总结","text":"React Native 中的所有组件存在生命周期，了解其生命周期对于我们掌握一个组件从创建到销毁的整个完整的过程和优化逻辑有很大的帮助。 先来一张经典的生命周期图: getDefaultPropsgetDefaultProps 是创建前的准备工作，来设置默认 props 的值，所以严格地来说，这不是组件的生命周期的一部分。需要注意的是如果有从父组件传过来的同名的 props，那么会覆盖。还有就是多个实例间共享引用，而不是有多个。 getInitialState这个函数控件加载之前执行，返回值会被用于 state 的初始化值。 componentWillMount这个回调函数在初始化 render 之前执行，调用时机是在组件创建，并初始化了状态之后，在第一次绘制 render() 之前。可以在这里做一些业务初始化操作，也可以设置组件状态 setState。这个函数在整个生命周期中只被调用一次。 renderrender 函数会在组件渲染的时候调用，只允许返回一个最外层容器组件。render 函数内要尽量保持纯净，只渲染组件，就是不要这个函数里初始化或更改组件的 state 以及其他耗时的操作。 componentDidMount在初始化 render 之后只执行一次，在这个函数内，可以访问任何组件，我们从这个函数开始，就可以和 JS 其他框架交互了，例如设置计时 setTimeout 或者 setInterval，或者发起网络请求，但是需要注意：RN 框架是先调用子组件的 componentDidMount 函数，然后调用父组件的函数。 shouldComponentUpdate我们从上图中可以看出，这个函数在初始化 render 时不会执行，当 props 或者 state 发生变化的时候，才会调用该函数，并且是在render之前。这个函数会返回一个布尔值，如果返回 ture，则进行组件的重新渲染 render，相反返回 false，则不做任何处理。默认情况下，这个函数永远返回 true 用来保证数据变化的时候 UI 能够同步更新。但是在某些特定条件下，我们可以重载这一函数根据传递过来的 props 和 state 来选择是否更新，从而提高性能。 componentWillUpdate当 props 和 state 发生变化时执行，并且在 render 函数之前执行，当然初始化 render 时不执行该函数，需要特别注意的是，在这个函数里面，我们就不能使用 this.setState 来修改状态。这个函数调用之后，就会把 nextProps 和 nextState 分别设置到 this.props 和 this.state 中。紧接着这个函数，就会调用 render() 来更新界面了。 componentDidUpdate这个函数在组件更新渲染完成之后执行，初始化 render 时不执行，这里也不能使用 this.setState 来修改状态。 componentWillReceiveProps这个函数在接收到新的 props 时调用，一般是从父组件传递过来，初始化 render 时不执行，在这个回调函数里面，我们可以根据属性的变化，通过调用 this.setState() 来更新组件状态，旧的属性还是可以通过 this.props 来获取，这里调用更新状态是安全的，并不会触发额外的 render 调用。 componentWillUnmount当组件要被从界面上移除的时候，就会调用这个函数，在 componentDidMount 函数里面注册的事件需要在这里取消，例如计时器、网络请求等。 总结 生命周期 调用次数 能否使用 setSate() getDefaultProps 1 否 getInitialState 1 否 componentWillMount 1 是 render &gt;=1 否 componentDidMount 1 是 shouldComponentUpdate &gt;=0 否 componentWillUpdate &gt;=0 否 componentDidUpdate &gt;=0 否 componentWillReceiveProps &gt;=0 是 componentWillUnmount 1 否","link":"/2019/03/17/React Native 组件生命周期学习总结/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2017/09/15/hello-world/"},{"title":"一行代码获取ViewPager中当前显示的Fragment","text":"1. 前言 我不知道网上的那些答案为什么写的那么复杂, 明明一行代码可以搞定的事情, 写的这么麻烦 方式一 : 1mFragment = (MyFragment) mAdapter.instantiateItem(mPager, mPager.getCurrentItem()); 方式二 : 1mFragment = (MyFragment) getSupportFragmentManager().findFragmentByTag(&quot;android:switcher:&quot; + viewpager + &quot;:&quot; + mViewPager.getCurrentItem());","link":"/2017/11/07/一行代码获取ViewPager中当前显示的Fragment/"},{"title":"JetPack 简介","text":"JetPack是Google推出的一些库的集合。是Android基础支持库SDK以外的部分从官方的介绍来看。JetPack 总体包含四部分内容： 基础AppCompat ： 使得支持较低的 Android 版本。从以前继承 Activity 到现在继承 AppCompatActivity 就是属于这一部分。 Android KTX: Kotlin 的扩展支持库 Multidex: 多 dex 文件支持 Test: 测试支持库 架构Data Binding: MVVM的一种实践 Lifecycles: 管理你的Activity 和 Fragment 生命周期 LiveData: 通过观察者模式感知数据变化，类比 RxJava Navigation: 处理 Fragment Paging: 分页数据加载方案 Room: 官方 ORM 库 ViewModel: 通过数据驱动V视图发生改变 WorkManager: 管理后台任务 行为Camerax: 轻松地向应用中添加相机功能 DownloadManager: 安排和管理大量下载任务 Media app： 用于媒体播放和路由（包括 Google Cast）的向后兼容API Notifications: 提供向后兼容的通知 API，支持 Wear 和 Auto Permissions: 用于检查和请求应用权限的兼容性 API Settings: 创建交互式设置屏幕 Share Action: 提供适合应用操作栏的共享操作。这块在国内使用的不多，都是自己封装或者采用第三方方案。 Slices: 可以让应用通过外部（其他APP）显示APP界面（通过设备自带的搜索，语音助手等） 界面界面部分所包含的东西基本是我们接触的最多的了： Animations and Transitions: 动画，界面转场等 Emoji: 在旧版平台上启用最新的表情符号字体 Fragment: 组件化界面的基本单位 Layout: 基础概念 Palette-Colors: 从调色板中提取出有用的信息 TV: 有助于开发 Android TV 应用的组件 Wear: 有助于开发 Wear 应用的组件","link":"/2019/12/17/JetPack 简介/"},{"title":"仿微信剪切视频时长View","text":"1. preview","link":"/2018/07/25/仿微信剪切视频时长View/"},{"title":"仿QQ空间打赏功能实现","text":"1. preview","link":"/2017/11/19/仿QQ空间打赏功能实现/"},{"title":"使用观察者模式进行订单管理","text":"概念：观察者模式是由发送者和观察者构成，发送者在状态改变时，主动通知所有的观察者做相应的刷新。观察者模式定义了对象之间一对多的依赖关系，以便一个对象状态发生改变时，所有依赖于它的对象都能够得到通知，并自动刷新。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * author: Kun on 2017/12/14 15:34 * address: vip@hellokk.cc * description: 订单管理观察者 用户对订单做了操作后，通知所有注册观察者的对象作相应的改变 */class OrderManageObserver { companion object { var list: MutableList&lt;OrderManageListener&gt;? = null var instance: OrderManageObserver? = null get() { if (field == null) { // 使用双重锁方式实现单例，保持只有一个实例 synchronized(OrderManageObserver::class.java) { if (field == null){ list = ArrayList() field = OrderManageObserver() } } } return field } } /** * 接受订单 */ fun orderReceivingClick(orderStep: Int?) { list?.forEach { // 通知所有观察者 it.orderReceiving(orderStep) } } /** * 订单删除 */ fun orderDeleteClick(orderStep: Int?) { list?.forEach { // 通知所有观察者 it.orderDelete(orderStep) } } /** * 注册订单监听 */ fun setOrderClick(orderFace: OrderManageListener) { list?.add(orderFace) }} 订单管理监听器 12345678910/** * author: Alan on 2018/1/6 14:01 * address: xk6321@gmail.com * description: 订单管理监听器 */interface OrderManageListener { fun orderReceiving(orderStep: Int?) // 接受订单 fun orderDelete(orderStep: Int?) // 订单删除} 注册观察者 12345678910OrderManageObserver.instance?.setOrderClick(object : OrderManageListener { override fun orderReceiving(orderStep: Int?) { // 在这里做相应操作 } override fun orderDelete(orderStep: Int?) { // 订单删除， 刷新列表 } }) 发送者 12345override fun orderDelSuccess(orderStep: Int?) { // 在订单删除成功后，通知所有的观察者做相应的操作 OrderManageObserver.instance?.orderDeleteClick(orderStep) } 总结：观察者模式看起来很高大上，其实说白了就是一个类维护了另一个类的一个集合，并通过这个集合绑定解绑或调用另一个类的方法，对程序的解耦有一定帮助。在这里，我只简单的实现了一下，如果项目比较大，且用的地方比较多的话，在设计底层框架的时候，可以利用多态的特性进行抽象，以便适用与各种场景。","link":"/2018/06/05/使用观察者模式进行订单管理/"},{"title":"关于 Kotlin 的一些小知识的总结","text":"1. Class在 Kotlin 中 Class 的默认修饰符是 final，是不可以被继承和重写的，如果需要进行重写，可以在类名前面加修饰符 open,像下面这样：1open class RunClass ｛｝ 2. 构造函数当我们只需要一个构造函数的时候，可以直接有下面这种方式进行声明： 12class CustomView(context: Context?, attrs: AttributeSet?, defStyleAttr: Int) : View(context, attrs, defStyleAttr) {} 有时候一个构造函数不够用的时候，可以使用 constructor 来声明： 123456789constructor(context: Context) : super(context) { init(context)}constructor(context: Context, attributeSet: AttributeSet) : super(context, attributeSet) { init(context, attributeSet)}constructor(context: Context, attributeSet: AttributeSet?, defstyle: Int) : super(context, attributeSet, defstyle) { init(context, attributeSet, defstyle)} 3. static 静态在 kotlin 中是不支持 static 关键字的，不过提供了另一种方案：companion object 关键字里面的内容都代表静态，可以是静态变量也可以是静态函数 1234567companion object { fun main(context: Context) { val child = ChildImpl() val run = RunClass(child) run.show(context, &quot;haha&quot;) }} ##4. 匿名内部类一般匿名内部类里面只有一个方法的时候，Kotlin 会默认帮我们转成 Lambda 表达式，但是有多个方法的时候，就需要我们自己来实现了，可以采用下面这种方式：12345678910111213viewpager.addOnPageChangeListener(object: ViewPager.OnPageChangeListener { override fun onPageScrollStateChanged(state: Int) { } override fun onPageScrolled(position: Int, positionOffset: Float, positionOffsetPixels: Int) { } override fun onPageSelected(position: Int) { } }) 5. 和 Java 的互通最常用的比如 startActivity，我们在 Java 文件中，该如何启动 kotlin 中的 activity: 1startActivity(Intent(activity, UserActivity::class.java)) 这些是目前自己开发中遇到的一些问题，基本可以满足一般的kotlin开发了，其他问题可以再查看 Kotlin 官方文档。 Kotlin中文教程文档","link":"/2017/09/11/关于 Kotlin 的一些小知识的总结/"},{"title":"JetPack 之 LiveData","text":"LiveData LiveData是一个可观察的数据持有者类。与常规observable不同，LiveData是生命周期感知的。 从官方文档的介绍上我们可以看到俩个关键词：可观察、生命周期感知。简单来说，Google 给我们提供了一个可以被观察的，并且拥有生命周期感知能力的类。那有什么用呢？ 直接上 demo： 入门1.1 初级官方 Demo123456789101112131415161718192021222324252627282930class NameViewModel : ViewModel() { // 创建LiveData val currentName: MutableLiveData&lt;String&gt; by lazy { MutableLiveData&lt;String&gt;() } // ViewModel 的其余部分...}class NameActivity : AppCompatActivity() { private lateinit var model: NameViewModel override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) // 获取ViewModel. model = ViewModelProviders.of(this).get(NameViewModel::class.java) // 创建更新UI的观察者. val nameObserver = Observer&lt;String&gt; { newName -&gt; // 更新UI，在本例中是一个TextView. nameTextView.text = newName } // 观察LiveData，将此活动作为生命周期所有者和观察者传入. model.currentName.observe(this, nameObserver) }} 1.2 Demo解释最开始我们先声明了一个NameViewModel的ViewModel，这部分内容在ViewModel篇有所提及。内部有一个MutableLiveData&lt;String&gt;的成员变量。说白了就是一个LiveData类型的String，我们使用时是借助LiveData的特性，但本质还是用String。 也就是说这里如果我们要用一个List&lt;String&gt;，那么此时就是MutableLiveData&gt;()。 Activity之中，我们先获取ViewModel，然后mModel.currentName.observe(...,...)，这里我们就是在观察LiveData。我们只需要在回调中处理我们自己的UI操作即可了。也就是demo中的mNameTextView.text = newName。 LiveData会在每一次postValue(...)或者value=...时，observe()便会回调，哪怕是null。 注意这里有俩个点需要特别注意： LiveData是生命周期感知的，在当前的LifecycleOwner不处于活动状态(例如onPasue()、onStop())时，LiveData是不会回调observe()的，因为没有意义。 如果LiveData没有被observe()，那么此时你调用这个LiveData的postValue(...)/value=...，是没有任何作用。这个我们可以在源码中看到。 1.3、不同的 LiveData 实现类 (系统实现)MutableLiveData： 上文咱们已经见过了，没什么特别的，就是LiveData的实现类。就相当于List和ArrayList的关系。 MediatorLiveData： MutableLiveData的子类，它是一个比较强大的LiveData，我们的map()、switchMap()都是基于它进行实现的。最大的特点是可以同时监听多个LiveData。 三、进阶3.1 map()初用过RxJava的小伙伴，估计会和我一样，被各种“姿势”的操作符所正经，比如常用的：map、flatMap...而LiveData中同样有这样的操作。 一个很常见的场景：我们通过一个唯一id去查询这个id下的实体类，并且要同时展示二者的数据。很简单的业务逻辑，在LiveData中的展示是这样的： 3.1.1 使用12345678910111213141516class NameViewModel : ViewModel() { val userIdLiveData = MutableLiveData&lt;Long&gt;() // 伪码:当userIdLiveData发生变化时，userLiveData中的map就会调用，那么我们就可以得到罪行的id val userLiveData: LiveData&lt;User&gt; = Transformations.map(userIdLiveData) { id-&gt; // 通过id拿到User，return一个User的实例user user }}// Activity中mModel.userLiveData.observe(this, Observer { user -&gt; // user变化后通知mNameTextView更新UI mNameTextView.text = user.name})// 给userIdLiveData设置id为1mModel.userIdLiveData.postValue(\"1\") 针对这个业务场景，我们只需要监听我们用户通知UI变化的LiveData(userLiveData)，然后通过userIdLiveData.postValue(&quot;1&quot;)来驱动数据的变化。 这里可能和我们传统的MVP的思想并不相同，毕竟MVVM和MVP还是有区别的，而MVVM的这种方式被称之为：数据驱动。 3.1.2 map() 源码我们直接点到Transformations.map()中。 12345678910111213@MainThreadpublic static &lt;X, Y&gt; LiveData&lt;Y&gt; map( @NonNull LiveData&lt;X&gt; source, @NonNull final Function&lt;X, Y&gt; mapFunction) { final MediatorLiveData&lt;Y&gt; result = new MediatorLiveData&lt;&gt;(); result.addSource(source, new Observer&lt;X&gt;() { @Override public void onChanged(@Nullable X x) { result.setValue(mapFunction.apply(x)); } }); return result;} 很简单，就是使用了MediatorLiveData，然后通过一个高阶函数，将高阶函数返回的内容，set到LiveData上，完成map()。 既然提到了MediatorLiveData，以及它的addSource()的方法，那么我们就来看看它的源码。 3.1.3 MediatorLiveData 源码 这部分没啥意思，可以直接跳过看3.1.4、map() 源码总结… 进入MediatorLiveData之中，我们会发现代码比较少。这里抽出俩块比较重点的内容，我们一同来感受一下： 123456789101112131415 @MainThreadpublic &lt;S&gt; void addSource(@NonNull LiveData&lt;S&gt; source, @NonNull Observer&lt;? super S&gt; onChanged) { Source&lt;S&gt; e = new Source&lt;&gt;(source, onChanged); Source&lt;?&gt; existing = mSources.putIfAbsent(source, e); if (existing != null &amp;&amp; existing.mObserver != onChanged) { throw new IllegalArgumentException( \"This source was already added with the different observer\"); } if (existing != null) { return; } if (hasActiveObservers()) { e.plug(); }} 从这段代码中，我们粗略可以得到一个信息，这里把我们的LiveData和Observer封装成了Source对象，并且这个对象，不能重复添加。 此外，Source的plug()方法，被调用。接下来我们去看一看这个内部类Source的实现： 1234567891011121314151617181920212223242526private static class Source&lt;V&gt; implements Observer&lt;V&gt; { final LiveData&lt;V&gt; mLiveData; final Observer&lt;? super V&gt; mObserver; int mVersion = START_VERSION; Source(LiveData&lt;V&gt; liveData, final Observer&lt;? super V&gt; observer) { mLiveData = liveData; mObserver = observer; } void plug() { mLiveData.observeForever(this); } void unplug() { mLiveData.removeObserver(this); } @Override public void onChanged(@Nullable V v) { if (mVersion != mLiveData.getVersion()) { mVersion = mLiveData.getVersion(); mObserver.onChanged(v); } }} 首先Source是一个观察者，可以看到，我们外部使用的Observer会以Source的成员变量的形式，添加到传入的LiveData中。值得注意的是，这里使用了mLiveData.observeForever(this);。 从observeForever()用法可以看到，我们并没有传递LifecycleOwner，因此它并不具备生命感知能力。从注释中也可见一斑：This means that the given observer will receive all events and will never be automatically removed. 3.1.4 map() 源码总结打住，打住吧。其实没必要继续看了。一句话总结：map()的原理就是基于MediatorLiveData，MediatorLiveData内部会将传递进来的LiveData和Observer封装成内部类，然后放在内部维护的一个Map中。并且自动帮我们完成observeForever()和removeObserver()。 3.2 switchMap()3.2.1 使用switchMap()的场景可以应用在切换LiveData上。这话怎么解释呢？ 很常见的业务场景：比如你的业务用的是map()，map()中使用你自己写的络，而且LiveData运行的很良好，抽着烟喝着酒，啥事都没有…就比如，上面map()那样的代码： 12345678val userLiveData: LiveData&lt;User&gt; = Transformations.map(userIdLiveData) { id-&gt; // 自己的一段逻辑 user}// Activity中mViewModel.userLiveData.observe(this,Observer{-&gt;user //更新UI}) 突然有一天，这个地方数据结构、UI都没变，唯独变了逻辑。此时你一个同事写好了一个方法，让你替换一下就好了。不过当你调用的时候突然返现，这个方法返回一个LiveData对象！ 当然此时我们可以让UI重新observe()这个LiveData对象： 123456val otherLiveData:LiveData&lt;User&gt; = // 同事的逻辑// Activity中重新observe()mViewModel.otherLiveData.observe(this,Observer{-&gt;user //更新UI}) 可是这样的话，自己之前写的东西不都白费了么？所以此时，我们可以使用switchMap()，我们只需要很少的改动，就可以设配这次需求的变动： 123val userLiveData: LiveData&lt;User&gt; = Transformations.switchMap(userIdLiveData) { id-&gt; // 直接把同事的代码放在这里即可} 3.2.2、switchMap() 源码有了上边map()源码基础，我们可以很容易的看出switchMap()的端倪： 12345678910111213141516171819202122232425262728293031323334@MainThreadpublic static &lt;X, Y&gt; LiveData&lt;Y&gt; switchMap( @NonNull LiveData&lt;X&gt; source, @NonNull final Function&lt;X, LiveData&lt;Y&gt;&gt; switchMapFunction) { final MediatorLiveData&lt;Y&gt; result = new MediatorLiveData&lt;&gt;(); result.addSource(source, new Observer&lt;X&gt;() { LiveData&lt;Y&gt; mSource; @Override public void onChanged(@Nullable X x) { // 从Function中拿到返回的LiveData，也就是我们新的LiveData(文章背景中同事写的LiveData) LiveData&lt;Y&gt; newLiveData = switchMapFunction.apply(x); if (mSource == newLiveData) { return; } // remove掉旧的LiveData if (mSource != null) { result.removeSource(mSource); } mSource = newLiveData; if (mSource != null) { // add新的LiveData result.addSource(mSource, new Observer&lt;Y&gt;() { @Override public void onChanged(@Nullable Y y) { // 通知LiveData发生变化 result.setValue(y); } }); } } }); return result;} 我们对比一下switchMap()和map()的参数类型： Function&lt;X, LiveData&lt;Y&gt;&gt; switchMapFunction Function&lt;X, Y&gt; mapFunction 很明显一个是返回LiveData类型，一个是换一种类型。这也说明了，这俩个方法的不一样之处。 代码解释可以看注释，很直白的思路。 3.3、MediatorLiveData 的使用上述我们看过了map()和switchMap()的用法。各位应该都注意到MediatorLiveData这个类的作用。 上边我们一直都在操作一个LiveData，但是我们需求很容易遇到多种状态的变化。就像官方的demo： 123456LiveData liveData1 = ...;LiveData liveData2 = ...;MediatorLiveData liveDataMerger = new MediatorLiveData&lt;&gt;();liveDataMerger.addSource(liveData1, value -&gt; liveDataMerger.setValue(value));liveDataMerger.addSource(liveData2, value -&gt; liveDataMerger.setValue(value)); 如同demo所示，我们可以同时add多个LiveData，根据不同的LiveData的变化，处理我们不同的逻辑。最后通过MediatorLiveData回调到我们的UI上。 四、源码分析注册 Observer 1234567891011121314151617181920@MainThreadpublic void observe(@NonNull LifecycleOwner owner, @NonNull Observer&lt;? super T&gt; observer) { // 如果当前生命周期是DESTROYED，直接return if (owner.getLifecycle().getCurrentState() == DESTROYED) { return; } // 这个包装类，做了一件事情，在DESTROYED，移除Observer LifecycleBoundObserver wrapper = new LifecycleBoundObserver(owner, observer); // 添加在已经Observer，已存在且在Attach上后直接抛异常，也就是不能重复add ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper); if (existing != null &amp;&amp; !existing.isAttachedTo(owner)) { throw new IllegalArgumentException(\"Cannot add the same observer\" + \" with different lifecycles\"); } if (existing != null) { return; } // 把Wrapper添加到LifecycleOwner上 owner.getLifecycle().addObserver(wrapper);} Observer如何被响应： 1234567public interface Observer&lt;T&gt; { /** * Called when the data is changed. * @param t The new data */ void onChanged(T t);} 触发的起点，很明显是我们在set/postValue的时候： 1234567891011121314151617181920212223242526272829303132333435@MainThreadprotected void setValue(T value) { // 记住这个值，它是用来表示数据是否发生变化的 mVersion++; mData = value; dispatchingValue(null);}void dispatchingValue(@Nullable ObserverWrapper initiator) { // 省略部分代码 for (Iterator&lt;Map.Entry&lt;Observer&lt;? super T&gt;, ObserverWrapper&gt;&gt; iterator = mObservers.iteratorWithAdditions(); iterator.hasNext(); ) { // 往里走 considerNotify(iterator.next().getValue()); if (mDispatchInvalidated) { break; } } // 省略部分代码}private void considerNotify(ObserverWrapper observer) { // 如果observer不在活动期，则直接return。也就是上述说observer不在前台，将不会接受回调。 if (!observer.mActive) { return; } // 省略部分代码 // 很直白的version对比 if (observer.mLastVersion &gt;= mVersion) { return; } observer.mLastVersion = mVersion; // 回调 observer.mObserver.onChanged((T) mData);} observer.mActive在哪被赋值？很多地方。除了一些边界条件的赋值外，一个比较正式的赋值,ObserverWrapper中的void activeStateChanged(boolean newActive)方法： 1234567891011121314void activeStateChanged(boolean newActive) { if (newActive == mActive) { return; } mActive = newActive;}// 此方法最终会调到此方法@Overrideboolean shouldBeActive() { return mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED);}public boolean isAtLeast(@NonNull State state) { return compareTo(state) &gt;= 0;} 很简单，每次生命周期回调，observer.mActive都会被赋值，而只有到Lifecycle是活动状态是，mActive才会true。因此只有在我们的Activity为前台时我们的LiveData才会被回调。","link":"/2019/12/17/JetPack 之 LiveData/"},{"title":"响应式函数编程 RxJava & RxAndroid","text":"Github: https://github.com/ReactiveX/RxJava 中文资料: https://github.com/lzyzsd/Awesome-RxJava https://www.zhihu.com/question/35511144 用途: 异步操作 在程序逻辑异常复杂的情况下,仍然可以让代码的逻辑保持简洁 配置: 添加依赖: compile &apos;io.reactivex:rxjava:1.1.3&apos; compile &apos;io.reactivex:rxandroid:1.1.0&apos; //如果结合Retrofit使用,需要添加以下依赖 compile &apos;com.squareup.retrofit2:retrofit:2.0.1&apos; compile &apos;com.squareup.retrofit2:converter-gson:2.0.1&apos; compile &apos;com.squareup.retrofit2:adapter-rxjava:2.0.1&apos; 基本概念: 1. 被观察者: Observable 作用: 决定什么时候触发事件以及触发怎样的事件 创建方法: Observable.just(T…) 参数为单个的 Observable.from(T[]) / Observable.from(Iterable&lt;? extends T&gt;) 参数为数组或Iterable 2. 观察者: Observer 作用: 当事件触发的时候将有怎样的行为 实现类有Observer / Subscriber 3. 订阅: subscribe 作用: 把Observable和Observer关联起来 方法: observable.subscribe(observer); observable.subscribe(subscriber);4. 事件: onNext()：普通事件 onCompleted():事件队列完结 onError(): 事件队列异常 需要注意的是onCompleted()和onError()是互斥的.调用了其中一个就不应该触发另一个.5. 案例: 现有一个数组 String[] arr ={“afdsa”, “bfdsa”, “cfda”}, 把其中以字母”a”开头的字符串找出来并加上”from Alpha”,最后打印出新的字符串的长度 private void simpleDemo() { String[] arr = {&quot;afdsa&quot;, &quot;bfdsa&quot;, &quot;cfda&quot;}; Observable .from(arr) .filter(new Func1&lt;String, Boolean&gt;() { @Override public Boolean call(String s) { return s.startsWith(&quot;a&quot;); } }) .map(new Func1&lt;String, String&gt;() { @Override public String call(String s) { return s + &quot; from Alpha&quot;; } }) .subscribe(new Action1&lt;String&gt;() { @Override public void call(String s) { System.out.println(&quot;Rxjava:&quot; + s.length()); } }); for (int i = 0; i &lt; arr.length; i++) { String temp = arr[i]; if (temp.startsWith(&quot;a&quot;)) { temp += &quot; from Alpha&quot;; System.out.println(&quot;Normal:&quot; + temp.length()); } } 由指定的一个 drawable 文件 id 取得图片，并显示在 ImageView 中，并在出现异常的时候打印 Toast 报错： private void simpleDemo() { final int drawID = R.mipmap.ic_launcher; Observable .create(new Observable.OnSubscribe&lt;Drawable&gt;() { @Override public void call(Subscriber&lt;? super Drawable&gt; subscriber) { Drawable drawable = getResources().getDrawable(drawID); subscriber.onNext(drawable); subscriber.onCompleted(); } }) .subscribe(new Observer&lt;Drawable&gt;() { @Override public void onCompleted() { } @Override public void onError(Throwable e) { Toast.makeText(MainActivity.this, &quot;Error&quot;, Toast.LENGTH_SHORT).show(); } @Override public void onNext(Drawable drawable) { imageView.setImageDrawable(drawable); } }); } 6. Scheduler 作用: 控制线程.指定某一段代码在那个线程里运行. 内置的Scheduler: Schedulers.immediate(): 直接在当前线程运行，相当于不指定线程。这是默认的 Scheduler。 Schedulers.newThread(): 总是启用新线程，并在新线程执行操作。 Schedulers.io(): I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程。 Schedulers.computation(): 计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU。 AndroidSchedulers.mainThread(): Android专用,它指定的操作将在 Android 主线程运行。 指定线程的方法: Observable.subscribeOn():指定 subscribe() 所发生的线程，即 Observable.OnSubscribe 被激活时所处的线程。或者叫做事件产生的线程 Observable.observeOn():指定 Subscriber 所运行在的线程。或者叫做事件消费的线程。 7. 数据变换: 作用: 就是将事件序列中的对象或整个序列进行加工处理，转换成不同的事件或事件序列 Observable.map: 一对一的转换 private void simpleDemo() { Observable .just(R.mipmap.ic_launcher) .map(new Func1&lt;Integer, Drawable&gt;() { @Override public Drawable call(Integer integer) { return getResources().getDrawable(integer); } }) .subscribe(new Action1&lt;Drawable&gt;() { @Override public void call(Drawable drawable) { imageView.setImageDrawable(drawable); } }); } Observable.flatMap: 一对多的转换 public class Course { private String name; private int id; public Course(String name, int id) { this.name = name; this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getId() { return id; } public void setId(int id) { this.id = id; } } public class Student { private String name; private ArrayList&lt;Course&gt; courses; public Student(String name, ArrayList&lt;Course&gt; courses) { this.name = name; this.courses = courses; } public String getName() { return name; } public void setName(String name) { this.name = name; } public ArrayList&lt;Course&gt; getCourses() { return courses; } public void setCourses(ArrayList&lt;Course&gt; courses) { this.courses = courses; } } private void student() { Course yuwen = new Course(&quot;语文&quot;, 1); Course shuxue = new Course(&quot;数学&quot;, 2); Course yingyu = new Course(&quot;英文&quot;, 3); Course lishi = new Course(&quot;历史&quot;, 4); Course zhengzhi = new Course(&quot;政治&quot;, 5); Course xila = new Course(&quot;希腊语&quot;, 6); ArrayList&lt;Course&gt; course1 = new ArrayList&lt;&gt;(); course1.add(yuwen); course1.add(shuxue); course1.add(yingyu); course1.add(lishi); course1.add(zhengzhi); course1.add(xila); Student zhangsan = new Student(&quot;zhangsan&quot;, course1); Observable.just(zhangsan) .flatMap(new Func1&lt;Student, Observable&lt;Course&gt;&gt;() { @Override public Observable&lt;Course&gt; call(Student student) { return Observable.from(student.getCourses()); } }).subscribe(new Action1&lt;Course&gt;() { @Override public void call(Course course) { System.out.println(course.getName()); } }); } 8. 和Retrofit一起使用 添加依赖: compile &apos;com.squareup.retrofit2:retrofit:2.0.1&apos; compile &apos;com.squareup.retrofit2:converter-gson:2.0.1&apos; compile &apos;com.squareup.retrofit2:adapter-rxjava:2.0.1&apos; 利用http://www.jsonschema2pojo.org/创建数据模型 创建REST API 接口.注意此时返回的不能是Call而是Observable.示例代码: public interface LocationInterface { // http://ip.taobao.com/service/getIpInfo.php?ip=202.178.10.23 @GET(&quot;/service/getIpInfo.php&quot;) public Observable&lt;Location&gt; getLocation(@Query(&quot;ip&quot;) String ip); } 创建Retrofit对象,发起请求.注意此时Retrofit需要添加addCallAdapterFactory.示例代码: Retrofit retrofit = new Retrofit.Builder() .baseUrl(BASE2) .addConverterFactory(GsonConverterFactory.create()) .addCallAdapterFactory(RxJavaCallAdapterFactory.create()) .build(); LocationInterface locationInterface = retrofit.create(LocationInterface.class); Observable&lt;Location&gt; location = locationInterface.getLocation(&quot;8.8.8.8&quot;); location .subscribeOn(Schedulers.io()) .map(new Func1&lt;Location, String&gt;() { @Override public String call(Location location) { return location.getData().getCountry(); } }) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Action1&lt;String&gt;() { @Override public void call(String s) { textView.setText(s); } });","link":"/2018/05/21/响应式函数编程 RxJava & RxAndroid /"},{"title":"Kotlin 中使用 Anko 编写布局","text":"使用 Kotlin 开发已经开发两个项目了。说大幅度的减少了 Java 代码一点不夸张。用 Java 的时候动不动就 new 一个 OnClickListener() 匿名类，动不动就类型转换的地方都可以省下很多。更不用说特殊的地方使用 data class 更是少些不知道多少代码。 Jetbrains 给 Android 带来的不仅是 Kotlin，还有 Anko。从 Anko 的官方说明来看这是一个雄心勃勃的要代替 XML 写 Layout 的新的开发方式。 Anko 最重要的一点是引入了 DSL（Domain Specific Language）的方式开发 Android 界面布局。当然，本质是代码实现布局。不过使用 Anko 完全不用经历 Java 纯代码写 Android 的痛苦。因为本身是来自 Kotlin 的，所以自然的使用这种方式开发就具有了： 类型安全，不再需要那么多的 findById() 之后的类型转换。 null 安全，Kotlin 里，如果一个变量用？表示为可空，并且使用？之后再调用的时候，即使变量为空也不会引发异常。 无需设备解析 XML，因为 Anko 本质是代码实现的界面和布局，所以省去了这些麻烦。 代码复用，可以通过继承 AnkoComponent 的方式实现代码复用。XML 布局是每一个 Activity，每一个 View 各自专属一个，代码复用比较少。 来一个例子看一下： 使用 XML 123456789101112131415161718&lt;RelativeLayout&gt; &lt;TextView android:id=\"@+id/sample_text_view\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_alignParentTop=\"true\" android:text=\"Sample text view\" android:textSize=\"25sp\" /&gt; &lt;Button android:id=\"@+id/sample_button\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_below=\"@+id/sample_text_view\" android:text=\"Sample button\" /&gt;&lt;/RelativeLayout&gt; 使用 Anko relativeLayout { val textView = textView(&quot;Sample text view&quot;) { textSize = 25f }.lparams { width = matchParent alignParentTop() } button(&quot;Sample button&quot;).lparams { width = matchParent below(textView) } } 使用前需要在在 build.gradle 里添加下面的代码： dependencies { compile &apos;org.jetbrains.anko:anko-sdk15:0.8.3&apos; // sdk19, sdk21, sdk23 are also available compile &apos;org.jetbrains.anko:anko-support-v4:0.8.3&apos; // In case you need support-v4 bindings compile &apos;org.jetbrains.anko:anko-appcompat-v7:0.8.3&apos; // For appcompat-v7 bindings } 写一个 ListView 热身首先创建一个 ListView 的 item 点击之后跳转的 activity。这里叫做 TabDemo1。 现在就创建这个 listview，并在 listview 的 item 点击之后调转到相应的 activity 去。这个 listview 非常简单，只在一个竖直的布局中放置，并且宽度和高度都是填满竖直布局。 // 1 verticalLayout { padding = dip(16) // 2 val list = listView() { // 3 adapter = ArrayAdapter&lt;String&gt;(this@MainActivity, android.R.layout.simple_list_item_1, items) // 4 onItemClickListener = object : AdapterView.OnItemClickListener { override fun onItemClick(parent: AdapterView&lt;*&gt;?, v: View?, position: Int, id: Long) { when (position) { 0 -&gt; { // 5 startActivity&lt;TabDemo1&gt;() } } } } }.lparams(width = matchParent) { // 6 height = matchParent } } 分别解释： 竖直布局。本质是 LinearLayout，并且 orientation 的值为 vertical。但是水平方向的就没有 vetialLayout 这种可以直接使用的了，需要自己写明orientation。 创建一个 listview。 给这个 listview 添加 adapter。这里简单实用 ArrayAdapter。 添加 OnItemClickListener。object : AdapterView.OnItemClickListener 用来创建实现某个接口的匿名类。 startActivity()，是Anko的语法糖。startActivity(SourceActivity.this, DestActivity.class)可以直接简化为 startActivity()。简单了不少。 在 lparams 中设置 layout params 相关的内容。默认的都是 wrap content。这个设置为宽、高都为 match parent。 用 Fragment 写一个 Tab 布局 下面要开发的是一个日记 App。一共有三个 tab，第一个是日记列表，第二个 tab 是写日记，第三个 tab 可以设置一些字体大小等（这里只用来占位，不做实现）。 每一个 tab 都用一个 Fragment 来展示内容。这三个 tab 分别 HomeListFragment, DetailFragment,DiarySettingsFragment。 这三个 fragment 都在一个叫做 TabDemo1 的托管 Activity 里。 现在就从这个托管 activity：TabDemo1 开始。这里我们不使用默认的 ActionBar，而是用完全自定义的方式来写一个我们自己的 action bar。所以需要把界面设定为全屏模式。设置全屏的模式的方法有很多，我们用设置 style 的方式来实现。 &lt;style name=&quot;AppTheme.NoActionBar&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt; &lt;/style&gt; 之后把这个 style 应用在 activity 在 AndroidManifest.xml 配置中。 这个时候这个托管 activity 的界面布局就是一个完全的白板了。这个白板现在要分为上中下三部分。上部为我们自定义的 action bar，最下面的是 tab bar，剩下的部分就是每个 tab 的内容的fragment。 我们来看一下这个布局应该怎么写： // 1 relativeLayout { id = ID_RELATIVELAYOUT backgroundColor = Color.LTGRAY // 2 linearLayout { id = ID_TOP_BAR backgroundColor = ContextCompat.getColor(ctx, R.color.colorPrimary) orientation = LinearLayout.HORIZONTAL titleTextView = textView { text = &quot;Some Title&quot; textSize = 16f textColor = Color.WHITE gravity = Gravity.CENTER_HORIZONTAL or Gravity.CENTER_VERTICAL }.lparams { width = dip(0) height = matchParent weight = 1f } }.lparams { width = matchParent height = dip(50) alignParentTop() } // 3 linearLayout { id = ID_BOTTOM_TAB_BAR orientation = LinearLayout.HORIZONTAL backgroundColor = Color.WHITE // 4 homeListTab = weightTextView { text = &quot;List&quot; normalDrawable = resources.getDrawable(R.mipmap.tab_my_normal) selectedDrawable = resources.getDrawable(R.mipmap.tab_my_pressed) onClick { tabClick(0) } } detailTab = weightTextView { text = &quot;Detail&quot; normalDrawable = resources.getDrawable(R.mipmap.tab_channel_normal) selectedDrawable = resources.getDrawable(R.mipmap.tab_channel_pressed) onClick { tabClick(1) } } settingsTab = weightTextView { text = &quot;Settings&quot; normalDrawable = resources.getDrawable(R.mipmap.tab_better_normal) selectedDrawable = resources.getDrawable(R.mipmap.tab_better_pressed) onClick { tabClick(2) } } }.style { // 5 view -&gt; when (view) { is TextView -&gt; { view.padding = dip(5) view.compoundDrawablePadding = dip(3) view.textSize = 10f view.gravity = Gravity.CENTER } else -&gt; { } } }.lparams { height = dip(50) width = matchParent alignParentBottom() } // 6 fragmentContainer = frameLayout { id = ID_FRAMELAYOUT backgroundColor = Color.GREEN }.lparams { below(ID_TOP_BAR) above(ID_BOTTOM_TAB_BAR) width = matchParent height = matchParent } } 前文的例子用了一个 verticalLayout, 这里用的是 relativeLayout 的布局。这里是自定义 action bar。使用换一个 linearLayout。如前所述，要横向布局 linear layout就需要单独的指定 orientation：orientation =LinearLayout.HORIZONTAL。这里比较简单，只有一个显示 title 的 textView。 这里需要注意 gravity = Gravity.CENTER_HORIZONTAL or Gravity.CENTER_VERTICAL 可以直接写成 gravity = Gravity.CENTER。这里是为了突出or的用法。Kotlin 里的 or就是 java 的 | 操作符的作用。 这部分的布局是 tab bar。 这里用的是 weightTextView 而不是 textView。后面会详细的讲解这一部分。给 tab bar 添加 style。此 style 不是彼 style。这个 style，会遍历 tab bar 的 linear layout 内部的全部的 view，然后根据 when 表达式匹配对应的规则，之后给对应于规则的 view 设置相应的属性。比如，这里会用 when 语句查看 view 是否为 textView，如果是的话就给这个 view 设置 padding、drawable padding、text size 以及 gravity 属性。tab bar 的 linear layout有三个 text view，所以他们都会被设置这些属性。每一个 tab 的内容展示用 fragment 就是这里了。准确的说是 fragment 的 container。这个 container 是一个 framelayout。在 action bar 之下，在 tab bar 之上。在布局的时候有 below(ID_TOP_BAR), above(ID_BOTTOM_TAB_BAR)。ID_TOP_BAR 和 ID_BOTTOM_TAB_BAR 就分别是 action bar 和 tab bar 的 id 值。这些 id 值自由设定。另外，在 java 写的时候常用的 findViewById() 方法在 Kotlin 和 Anko 中可以改为的find(ID_FRAMELAYOUT)。不见得简单，但是增加了类型安全。不用再强制类型转换。也不用担心相关的错误再发生。 上文第4点用到了 weightTextView。这是一个自定义的 view。在 Anko 布局中，可以根据自己的需要自定义各种各样的 view。但是，需要经过一个小小的处理之后才可以使用到 Anko 的布局中。这个小小的处理就叫做扩展。下面看看如何给 Anko 添加 weightTextView 扩展的。 首先自定义一个 view：WeightTextView。 class WeightTextView(context: Context) : TextView(context) { var normalDrawable: Drawable? = null var selectedDrawable: Drawable? = null init { var layoutParams = LinearLayout.LayoutParams(dip(50), LinearLayout.LayoutParams.MATCH_PARENT, 1f) layoutParams.weight = 1f this.layoutParams = layoutParams } override fun setSelected(selected: Boolean) { super.setSelected(selected) if (selected) { this.backgroundColor = ContextCompat.getColor(context, R.color.textGray) this.textColor = ContextCompat.getColor(context, R.color.textYellow) if (selectedDrawable != null) { this.setCompoundDrawablesWithIntrinsicBounds(null, selectedDrawable, null, null) } } else { this.backgroundColor = ContextCompat.getColor(context, android.R.color.transparent) this.textColor = ContextCompat.getColor(context, R.color.textGray) if (normalDrawable != null) { this.setCompoundDrawablesWithIntrinsicBounds(null, normalDrawable, null, null) } } } } 附加解释：方法 setSelected() 是被迫添加的。在使用 Anko，相当于使用代码开发 Android 布局的时候 selector 不起作用。只好把点击后的高亮效果写在自定义的 text view 里。 下面看看如何扩展 Anko，来使用我们上面的自定义 view。 public inline fun ViewManager.weightTextView() = weightTextView {} public inline fun ViewManager.weightTextView(init: WeightTextView.() -&gt; Unit) = ankoView({ WeightTextView(it) }, init) 这部分涉及到的语法内容可以参考官网。这里简单介绍一下。拿官网的例子说一下： class HTML { fun body() { ... } } 现在有这么一个 HTML 类，那么调用的时候可以这样： html { body() } 在这么一个 lambda 表达式里就可以直接这样调用 HTML 类的方法了，中间的过程是怎么样的呢 fun html(init: HTML.() -&gt; Unit): HTML { val html = HTML() // create the receiver object html.init() return html } 其实灰常的简单呢。在方法 html() 里，参数是一个 HTML 类的扩展方法，并且此方法无参，返回 Unit(java的void)。 在方法执行的过程中，首先初始化了 HTML。之后调用了这个作为参数传入的扩展方法。在具体调用 html() 方法的时候，可以只简单写一个 lambda 表达式作为传入的 HTML 扩展方法。既然是一个类的扩展方法，那当然可以调用这个类内部的方法了。 为了帮助理解，这里给出一个参数是方法的方法： fun main(args: Array&lt;String&gt;) { calling(&quot;yo&quot;) { p -&gt; println(&quot;method called $p&quot;) } calling(&quot;yoyo&quot;, ::called) } fun calling(param: String, func: (String) -&gt; Unit) { func(param) } fun called(p: String) { println(&quot;output string $p&quot;) } 第一个是用 lambda 表达式作为传入方法，第二个是已经定义好的一个方法作为传入方法。 Fragment 的处理本文中的重点在于使用 Anko 做布局，具体的逻辑处理 java 写和 Kotlin 写没有什么区别。这里只简单介绍一下。 为了保证兼容，这里使用 Support v4 来处理 Fragment 的显示等操作。在 activity 的一开始就把需要的 fragemnt 都加载进来。 fun prepareTabFragments() { val fm = supportFragmentManager homeListFragment = HomeListFragment.newInstance() fm.beginTransaction() .add(ID_FRAMELAYOUT, homeListFragment) .commit() detailFragment = DetailFragment.newInstance(null) detailFragment?.modelChangeListener = homeListFragment fm.beginTransaction() .add(ID_FRAMELAYOUT, detailFragment) .commit() settingsFragment = DiarySettingsFragment.newInstance() fm.beginTransaction() .add(ID_FRAMELAYOUT, settingsFragment) .commit() } 每一个 tab 项被点击的时候的处理： fun tabClick(index: Int) { info(&quot;index is $index&quot;) val ft = supportFragmentManager.beginTransaction() ft.hide(homeListFragment) ft.hide(detailFragment) ft.hide(settingsFragment) // unselect all textviews homeListTab?.isSelected = false detailTab?.isSelected = false settingsTab?.isSelected = false when (index) { 0 -&gt; { homeListTab?.isSelected = true ft.show(homeListFragment) } 1 -&gt; { detailTab?.isSelected = true ft.show(detailFragment) } 2 -&gt; { settingsTab?.isSelected = true ft.show(settingsFragment) } else -&gt; { } } ft.commit() } 分别开始每一个 Fragment在开始之前需要考虑一个很严重的事情：数据存在什么地方。本来应该是 SQLite 或者存在云上的。存在云裳就可以实现同一个账号登录在任何地方都可以同步到同样的内容。这里只简单模拟，存放在 app 的内存里。存放在 Application 派生类 AnkoApplication 的静态属性 diaryDataSource 里。diaryDataSource 是一个 ArrayList 一样的列表。 class AnkoApplication : Application() { override fun onCreate() { super.onCreate() } companion object { var diaryDataSource = mutableListOf&lt;DiaryModel&gt;() } } 第一个 tab，HomeListFragmentHomeListFragment 类作为第一个 tab 内容展示 fragment，用来显示全部的日记列表的布局就非常简单了，和我们前面的例子没有什么太大的差别。就是在一个 verticalLayout 里放一个 list view。这个 list view 的 data source 只需要一个列表。 // 1 var view = with(ctx) { verticalLayout { backgroundColor = Color.WHITE listView = listView { adapter = ArrayAdapter&lt;DiaryModel&gt;(ctx, android.R.layout.simple_list_item_1, AnkoApplication.diaryDataSource) onItemClick { adapterView, view, i, l -&gt; toast(&quot;clicked index: $i, content: ${AnkoApplication.diaryDataSource[i].toString()}&quot;) } } // 2 emptyTextView = textView { text = resources.getString(R.string.list_view_empty) textSize = 30f gravity = Gravity.CENTER }.lparams { width = matchParent height = matchParent } } } // 3 listView?.emptyView = emptyTextView return view 在 activity 里的布局可以直接写 vertical{}，但是在 fragment 里不可以这样。直接写 vertical{} 就已经把这个layout添加到父 view 上了，这 fragment 里是不行的。在 fragment 里需要创建一个单独的 view，并返回。用 with 语句来创建这样一个单独的 view。在 vertial layout 里添加了一个 textview。上面一步创建的 textview 作为 list view 没有数据的时候显示的 empty view 来使用。第二个 tab，DetailFragment日记的内容包括，日记 title，日记本身的内容还有日记的日期。 所以布局上就包括日记的 title 内容输入用的 EditText 以及为了说明用的 text view，还有 edit text 里的 hint。最后还有一个选择日期的控件。 return with(ctx) { verticalLayout { padding = dip(10) backgroundColor = Color.WHITE textView(&quot;TITLE&quot;) { }.lparams(width = matchParent) titleEditText = editText { hint = currentDateString() lines = 1 }.lparams(width = matchParent) { topMargin = dip(5) } textView(&quot;CONTENT&quot;) { }.lparams(width = matchParent) { topMargin = dip(15) } contentEditText = editText { hint = &quot;what&apos;s going on...&quot; setHorizontallyScrolling(false) }.lparams(width = matchParent) { // height = matchParent topMargin = dip(5) } button(R.string.button_select_time) { gravity = Gravity.CENTER onClick { val fm = activity.supportFragmentManager var datePicker = DatePickerFragment.newInstance(diaryModel?.date) datePicker.setTargetFragment(this@DetailFragment, DetailFragment.REQUEST_DATE) datePicker.show(fm, &quot;date&quot;) } } // * button(R.string.button_detail_ok) { onClick { v -&gt; println(&quot;ok button clicked&quot;) try { var model = diaryModel!! model.title = titleEditText?.text.toString() model.content = contentEditText?.text.toString() AnkoApplication.diaryDataSource.add(model) modelChangeListener?.modelChanged() toast(R.string.model_saved_ok) } catch(e: Exception) { Log.d(&quot;##DetailFragment&quot;, &quot;error: ${e.toString()}&quot;) toast(R.string.model_save_error) } } }.lparams { topMargin = dip(10) width = matchParent } }.style { view -&gt; when (view) { is Button -&gt; { view.gravity = Gravity.CENTER } is TextView -&gt; { view.gravity = Gravity.LEFT view.textSize = 20f view.textColor = Color.DKGRAY } } } } 需要注意打星号的地方。按钮在点击之后会弹出一个 dialog fragment 来显示日期 view。用户可以在这个日期 view 里选择相应的日期。但是，如何从日期 dialog fragment 传递选择的日期给 DetailFragment 呢？这里就涉及到两个 fragment 之间传递数据的问题。 选择日期的dialog fragment是DatePickerFragment。 var pickerView = DatePicker(activity) pickerView.calendarViewShown = false pickerView.layoutParams = ViewGroup.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT) pickerView.init(year, month, day) { view, year, month, day -&gt; mDate = GregorianCalendar(year, month, day).time arguments.putSerializable(EXTRA_DATE, mDate) } return AlertDialog.Builder(activity) .setView(pickerView) .setTitle(R.string.date_picker_title) .setPositiveButton(R.string.picker_button_ok) { dialog, which -&gt; toast(&quot;hello world!&quot;) sendResult(Activity.RESULT_OK) }.create() 首先 DatePickerFragment 要继承 DialogFragment 之后 override 方法 onCreateDialog(savedInstanceState: Bundle)。 在这个方法里使用上面代码创建一个包含日期选择器的 dialog。 在选择日期的时候，会触发 DatePicker 的 OnDateChangedListener 接口的 onDateChanged 方法。我们在这个方法里记录选择好的日期数据，在dialog的positive按钮点击之后把这个数据发送给 DetailFragment。 那么怎么发送呢？使用 target fargment 方法。在 detail fragment 弹出 dialog fragment 的时候，把 detail fragment 设置为 target fragment。 button(R.string.button_select_time) { gravity = Gravity.CENTER onClick { val fm = activity.supportFragmentManager var datePicker = DatePickerFragment.newInstance(diaryModel?.date) // * datePicker.setTargetFragment(this@DetailFragment, DetailFragment.REQUEST_DATE) datePicker.show(fm, &quot;date&quot;) } } 在标星下面的一行代码中。datePicker.setTargetFragment(this@DetailFragment,DetailFragment.REQUEST_DATE)将DetailFragment设定为target fragment，并且指定REQUEST_DATE这code，为以后取出数据使用。 companion object Factory { val REQUEST_DATE = 0` } 在 positive 按钮点击之后执行方法 sendResult 回传数据 private fun sendResult(resultCode: Int) { if (targetFragment == null) return var i = Intent() i.putExtra(EXTRA_DATE, mDate) // * targetFragment.onActivityResult(targetRequestCode, resultCode, i) } 调用 targetFragment 的 onActivityResult() 方法来回传日期数据。 在 DetailFragment 中通过 override 方法 onActivityResult() 来接收数据。 override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) { if (resultCode != Activity.RESULT_OK) { return } if (requestCode != REQUEST_DATE) { return } var date = data?.getSerializableExtra(DatePickerFragment.EXTRA_DATE) as Date diaryModel?.date = date } 日期数据传输这部分到这里结束。 全文也可以在这里画上一个句点了。以上还有很多关于 Anko 没有使用的地方。Anko 也是可以实现代码界面分离的。继承 AnkoComponent 可以写出独立的布局文件，并且可以用 anko preview 插件来预览界面效果。就拿 setting 这个 tab 的 fragment 来举例：首先定义一个独立的布局文件: class SettingsUI&lt;T&gt; : AnkoComponent&lt;T&gt; { override fun createView(ui: AnkoContext&lt;T&gt;) = with(ui) { verticalLayout { backgroundColor = ContextCompat.getColor(ctx, R.color.SnowWhite) textView { text = resources.getString(R.string.settings_title) } button(&quot;activity with the same `AnkoComponent`&quot;) { id = ID_BUTTON } } } companion object Factory { public val ID_BUTTON = 101 } } 把这个布局文件用在 DiarySettingsFragment 上： override fun onCreateView(inflater: LayoutInflater?, container: ViewGroup?, val view = SettingsUI&lt;DiarySettingsFragment&gt;().createView(AnkoContext.create(ctx, DiarySettingsFragment())) return view } 然后这个布局还可以用在我们刚刚创建的 TempActivity 上： override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) SettingsUI&lt;TempActivity&gt;().setContentView(this) val button = find&lt;Button&gt;(SettingsUI.ID_BUTTON) button.text = &quot;you are in `TempActivity`, CLICK!&quot; button.onClick { toast(&quot;${TempActivity::class.java.simpleName}&quot;) } } Activity 上使用就简单很多了，只需要这么一句 SettingsUI().setContentView(this)。","link":"/2018/06/05/Kotlin 中使用 Anko 编写布局/"}],"tags":[],"categories":[]}