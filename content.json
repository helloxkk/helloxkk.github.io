{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2017/09/15/hello-world/"},{"title":"使用观察者模式进行订单管理","text":"概念：观察者模式是由发送者和观察者构成，发送者在状态改变时，主动通知所有的观察者做相应的刷新。观察者模式定义了对象之间一对多的依赖关系，以便一个对象状态发生改变时，所有依赖于它的对象都能够得到通知，并自动刷新。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * author: Kun on 2017/12/14 15:34 * address: vip@hellokk.cc * description: 订单管理观察者 用户对订单做了操作后，通知所有注册观察者的对象作相应的改变 */class OrderManageObserver { companion object { var list: MutableList&lt;OrderManageListener&gt;? = null var instance: OrderManageObserver? = null get() { if (field == null) { // 使用双重锁方式实现单例，保持只有一个实例 synchronized(OrderManageObserver::class.java) { if (field == null){ list = ArrayList() field = OrderManageObserver() } } } return field } } /** * 接受订单 */ fun orderReceivingClick(orderStep: Int?) { list?.forEach { // 通知所有观察者 it.orderReceiving(orderStep) } } /** * 订单删除 */ fun orderDeleteClick(orderStep: Int?) { list?.forEach { // 通知所有观察者 it.orderDelete(orderStep) } } /** * 注册订单监听 */ fun setOrderClick(orderFace: OrderManageListener) { list?.add(orderFace) }} 订单管理监听器 12345678910/** * author: Alan on 2018/1/6 14:01 * address: xk6321@gmail.com * description: 订单管理监听器 */interface OrderManageListener { fun orderReceiving(orderStep: Int?) // 接受订单 fun orderDelete(orderStep: Int?) // 订单删除} 注册观察者 12345678910OrderManageObserver.instance?.setOrderClick(object : OrderManageListener { override fun orderReceiving(orderStep: Int?) { // 在这里做相应操作 } override fun orderDelete(orderStep: Int?) { // 订单删除， 刷新列表 } }) 发送者 12345override fun orderDelSuccess(orderStep: Int?) { // 在订单删除成功后，通知所有的观察者做相应的操作 OrderManageObserver.instance?.orderDeleteClick(orderStep) } 总结：观察者模式看起来很高大上，其实说白了就是一个类维护了另一个类的一个集合，并通过这个集合绑定解绑或调用另一个类的方法，对程序的解耦有一定帮助。在这里，我只简单的实现了一下，如果项目比较大，且用的地方比较多的话，在设计底层框架的时候，可以利用多态的特性进行抽象，以便适用与各种场景。","link":"/2018/06/05/使用观察者模式进行订单管理/"},{"title":"仿QQ空间打赏功能实现","text":"1. preview","link":"/2017/11/19/仿QQ空间打赏功能实现/"},{"title":"一行代码获取ViewPager中当前显示的Fragment","text":"1. 前言 我不知道网上的那些答案为什么写的那么复杂, 明明一行代码可以搞定的事情, 写的这么麻烦 方式一 : 1mFragment = (MyFragment) mAdapter.instantiateItem(mPager, mPager.getCurrentItem()); 方式二 : 1mFragment = (MyFragment) getSupportFragmentManager().findFragmentByTag(&quot;android:switcher:&quot; + viewpager + &quot;:&quot; + mViewPager.getCurrentItem());","link":"/2017/11/07/一行代码获取ViewPager中当前显示的Fragment/"},{"title":"仿微信剪切视频时长View","text":"1. preview","link":"/2018/07/25/仿微信剪切视频时长View/"},{"title":"关于 Kotlin 的一些小知识的总结","text":"1. Class在 Kotlin 中 Class 的默认修饰符是 final，是不可以被继承和重写的，如果需要进行重写，可以在类名前面加修饰符 open,像下面这样：1open class RunClass ｛｝ 2. 构造函数当我们只需要一个构造函数的时候，可以直接有下面这种方式进行声明： 12class CustomView(context: Context?, attrs: AttributeSet?, defStyleAttr: Int) : View(context, attrs, defStyleAttr) {} 有时候一个构造函数不够用的时候，可以使用 constructor 来声明： 123456789constructor(context: Context) : super(context) { init(context)}constructor(context: Context, attributeSet: AttributeSet) : super(context, attributeSet) { init(context, attributeSet)}constructor(context: Context, attributeSet: AttributeSet?, defstyle: Int) : super(context, attributeSet, defstyle) { init(context, attributeSet, defstyle)} 3. static 静态在 kotlin 中是不支持 static 关键字的，不过提供了另一种方案：companion object 关键字里面的内容都代表静态，可以是静态变量也可以是静态函数 1234567companion object { fun main(context: Context) { val child = ChildImpl() val run = RunClass(child) run.show(context, &quot;haha&quot;) }} ##4. 匿名内部类一般匿名内部类里面只有一个方法的时候，Kotlin 会默认帮我们转成 Lambda 表达式，但是有多个方法的时候，就需要我们自己来实现了，可以采用下面这种方式：12345678910111213viewpager.addOnPageChangeListener(object: ViewPager.OnPageChangeListener { override fun onPageScrollStateChanged(state: Int) { } override fun onPageScrolled(position: Int, positionOffset: Float, positionOffsetPixels: Int) { } override fun onPageSelected(position: Int) { } }) 5. 和 Java 的互通最常用的比如 startActivity，我们在 Java 文件中，该如何启动 kotlin 中的 activity: 1startActivity(Intent(activity, UserActivity::class.java)) 这些是目前自己开发中遇到的一些问题，基本可以满足一般的kotlin开发了，其他问题可以再查看 Kotlin 官方文档。 Kotlin中文教程文档","link":"/2017/09/11/关于 Kotlin 的一些小知识的总结/"},{"title":"响应式函数编程 RxJava & RxAndroid","text":"Github: https://github.com/ReactiveX/RxJava 中文资料: https://github.com/lzyzsd/Awesome-RxJava https://www.zhihu.com/question/35511144 用途: 异步操作 在程序逻辑异常复杂的情况下,仍然可以让代码的逻辑保持简洁 配置: 添加依赖: compile &apos;io.reactivex:rxjava:1.1.3&apos; compile &apos;io.reactivex:rxandroid:1.1.0&apos; //如果结合Retrofit使用,需要添加以下依赖 compile &apos;com.squareup.retrofit2:retrofit:2.0.1&apos; compile &apos;com.squareup.retrofit2:converter-gson:2.0.1&apos; compile &apos;com.squareup.retrofit2:adapter-rxjava:2.0.1&apos; 基本概念: 1. 被观察者: Observable 作用: 决定什么时候触发事件以及触发怎样的事件 创建方法: Observable.just(T…) 参数为单个的 Observable.from(T[]) / Observable.from(Iterable&lt;? extends T&gt;) 参数为数组或Iterable 2. 观察者: Observer 作用: 当事件触发的时候将有怎样的行为 实现类有Observer / Subscriber 3. 订阅: subscribe 作用: 把Observable和Observer关联起来 方法: observable.subscribe(observer); observable.subscribe(subscriber);4. 事件: onNext()：普通事件 onCompleted():事件队列完结 onError(): 事件队列异常 需要注意的是onCompleted()和onError()是互斥的.调用了其中一个就不应该触发另一个.5. 案例: 现有一个数组 String[] arr ={“afdsa”, “bfdsa”, “cfda”}, 把其中以字母”a”开头的字符串找出来并加上”from Alpha”,最后打印出新的字符串的长度 private void simpleDemo() { String[] arr = {&quot;afdsa&quot;, &quot;bfdsa&quot;, &quot;cfda&quot;}; Observable .from(arr) .filter(new Func1&lt;String, Boolean&gt;() { @Override public Boolean call(String s) { return s.startsWith(&quot;a&quot;); } }) .map(new Func1&lt;String, String&gt;() { @Override public String call(String s) { return s + &quot; from Alpha&quot;; } }) .subscribe(new Action1&lt;String&gt;() { @Override public void call(String s) { System.out.println(&quot;Rxjava:&quot; + s.length()); } }); for (int i = 0; i &lt; arr.length; i++) { String temp = arr[i]; if (temp.startsWith(&quot;a&quot;)) { temp += &quot; from Alpha&quot;; System.out.println(&quot;Normal:&quot; + temp.length()); } } 由指定的一个 drawable 文件 id 取得图片，并显示在 ImageView 中，并在出现异常的时候打印 Toast 报错： private void simpleDemo() { final int drawID = R.mipmap.ic_launcher; Observable .create(new Observable.OnSubscribe&lt;Drawable&gt;() { @Override public void call(Subscriber&lt;? super Drawable&gt; subscriber) { Drawable drawable = getResources().getDrawable(drawID); subscriber.onNext(drawable); subscriber.onCompleted(); } }) .subscribe(new Observer&lt;Drawable&gt;() { @Override public void onCompleted() { } @Override public void onError(Throwable e) { Toast.makeText(MainActivity.this, &quot;Error&quot;, Toast.LENGTH_SHORT).show(); } @Override public void onNext(Drawable drawable) { imageView.setImageDrawable(drawable); } }); } 6. Scheduler 作用: 控制线程.指定某一段代码在那个线程里运行. 内置的Scheduler: Schedulers.immediate(): 直接在当前线程运行，相当于不指定线程。这是默认的 Scheduler。 Schedulers.newThread(): 总是启用新线程，并在新线程执行操作。 Schedulers.io(): I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程。 Schedulers.computation(): 计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU。 AndroidSchedulers.mainThread(): Android专用,它指定的操作将在 Android 主线程运行。 指定线程的方法: Observable.subscribeOn():指定 subscribe() 所发生的线程，即 Observable.OnSubscribe 被激活时所处的线程。或者叫做事件产生的线程 Observable.observeOn():指定 Subscriber 所运行在的线程。或者叫做事件消费的线程。 7. 数据变换: 作用: 就是将事件序列中的对象或整个序列进行加工处理，转换成不同的事件或事件序列 Observable.map: 一对一的转换 private void simpleDemo() { Observable .just(R.mipmap.ic_launcher) .map(new Func1&lt;Integer, Drawable&gt;() { @Override public Drawable call(Integer integer) { return getResources().getDrawable(integer); } }) .subscribe(new Action1&lt;Drawable&gt;() { @Override public void call(Drawable drawable) { imageView.setImageDrawable(drawable); } }); } Observable.flatMap: 一对多的转换 public class Course { private String name; private int id; public Course(String name, int id) { this.name = name; this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getId() { return id; } public void setId(int id) { this.id = id; } } public class Student { private String name; private ArrayList&lt;Course&gt; courses; public Student(String name, ArrayList&lt;Course&gt; courses) { this.name = name; this.courses = courses; } public String getName() { return name; } public void setName(String name) { this.name = name; } public ArrayList&lt;Course&gt; getCourses() { return courses; } public void setCourses(ArrayList&lt;Course&gt; courses) { this.courses = courses; } } private void student() { Course yuwen = new Course(&quot;语文&quot;, 1); Course shuxue = new Course(&quot;数学&quot;, 2); Course yingyu = new Course(&quot;英文&quot;, 3); Course lishi = new Course(&quot;历史&quot;, 4); Course zhengzhi = new Course(&quot;政治&quot;, 5); Course xila = new Course(&quot;希腊语&quot;, 6); ArrayList&lt;Course&gt; course1 = new ArrayList&lt;&gt;(); course1.add(yuwen); course1.add(shuxue); course1.add(yingyu); course1.add(lishi); course1.add(zhengzhi); course1.add(xila); Student zhangsan = new Student(&quot;zhangsan&quot;, course1); Observable.just(zhangsan) .flatMap(new Func1&lt;Student, Observable&lt;Course&gt;&gt;() { @Override public Observable&lt;Course&gt; call(Student student) { return Observable.from(student.getCourses()); } }).subscribe(new Action1&lt;Course&gt;() { @Override public void call(Course course) { System.out.println(course.getName()); } }); } 8. 和Retrofit一起使用 添加依赖: compile &apos;com.squareup.retrofit2:retrofit:2.0.1&apos; compile &apos;com.squareup.retrofit2:converter-gson:2.0.1&apos; compile &apos;com.squareup.retrofit2:adapter-rxjava:2.0.1&apos; 利用http://www.jsonschema2pojo.org/创建数据模型 创建REST API 接口.注意此时返回的不能是Call而是Observable.示例代码: public interface LocationInterface { // http://ip.taobao.com/service/getIpInfo.php?ip=202.178.10.23 @GET(&quot;/service/getIpInfo.php&quot;) public Observable&lt;Location&gt; getLocation(@Query(&quot;ip&quot;) String ip); } 创建Retrofit对象,发起请求.注意此时Retrofit需要添加addCallAdapterFactory.示例代码: Retrofit retrofit = new Retrofit.Builder() .baseUrl(BASE2) .addConverterFactory(GsonConverterFactory.create()) .addCallAdapterFactory(RxJavaCallAdapterFactory.create()) .build(); LocationInterface locationInterface = retrofit.create(LocationInterface.class); Observable&lt;Location&gt; location = locationInterface.getLocation(&quot;8.8.8.8&quot;); location .subscribeOn(Schedulers.io()) .map(new Func1&lt;Location, String&gt;() { @Override public String call(Location location) { return location.getData().getCountry(); } }) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Action1&lt;String&gt;() { @Override public void call(String s) { textView.setText(s); } });","link":"/2018/05/21/响应式函数编程 RxJava & RxAndroid /"},{"title":"Kotlin 中使用 Anko 编写布局","text":"使用 Kotlin 开发已经开发两个项目了。说大幅度的减少了 Java 代码一点不夸张。用 Java 的时候动不动就 new 一个 OnClickListener() 匿名类，动不动就类型转换的地方都可以省下很多。更不用说特殊的地方使用 data class 更是少些不知道多少代码。 Jetbrains 给 Android 带来的不仅是 Kotlin，还有 Anko。从 Anko 的官方说明来看这是一个雄心勃勃的要代替 XML 写 Layout 的新的开发方式。 Anko 最重要的一点是引入了 DSL（Domain Specific Language）的方式开发 Android 界面布局。当然，本质是代码实现布局。不过使用 Anko 完全不用经历 Java 纯代码写 Android 的痛苦。因为本身是来自 Kotlin 的，所以自然的使用这种方式开发就具有了： 类型安全，不再需要那么多的 findById() 之后的类型转换。 null 安全，Kotlin 里，如果一个变量用？表示为可空，并且使用？之后再调用的时候，即使变量为空也不会引发异常。 无需设备解析 XML，因为 Anko 本质是代码实现的界面和布局，所以省去了这些麻烦。 代码复用，可以通过继承 AnkoComponent 的方式实现代码复用。XML 布局是每一个 Activity，每一个 View 各自专属一个，代码复用比较少。 来一个例子看一下： 使用 XML &lt;RelativeLayout&gt; &lt;TextView android:id=\"@+id/sample_text_view\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_alignParentTop=\"true\" android:text=\"Sample text view\" android:textSize=\"25sp\" /&gt; &lt;Button android:id=\"@+id/sample_button\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_below=\"@+id/sample_text_view\" android:text=\"Sample button\" /&gt; &lt;/RelativeLayout&gt; 使用 Anko relativeLayout { val textView = textView(&quot;Sample text view&quot;) { textSize = 25f }.lparams { width = matchParent alignParentTop() } button(&quot;Sample button&quot;).lparams { width = matchParent below(textView) } } 使用前需要在在 build.gradle 里添加下面的代码： dependencies { compile &apos;org.jetbrains.anko:anko-sdk15:0.8.3&apos; // sdk19, sdk21, sdk23 are also available compile &apos;org.jetbrains.anko:anko-support-v4:0.8.3&apos; // In case you need support-v4 bindings compile &apos;org.jetbrains.anko:anko-appcompat-v7:0.8.3&apos; // For appcompat-v7 bindings } 写一个 ListView 热身首先创建一个 ListView 的 item 点击之后跳转的 activity。这里叫做 TabDemo1。 现在就创建这个 listview，并在 listview 的 item 点击之后调转到相应的 activity 去。这个 listview 非常简单，只在一个竖直的布局中放置，并且宽度和高度都是填满竖直布局。 // 1 verticalLayout { padding = dip(16) // 2 val list = listView() { // 3 adapter = ArrayAdapter&lt;String&gt;(this@MainActivity, android.R.layout.simple_list_item_1, items) // 4 onItemClickListener = object : AdapterView.OnItemClickListener { override fun onItemClick(parent: AdapterView&lt;*&gt;?, v: View?, position: Int, id: Long) { when (position) { 0 -&gt; { // 5 startActivity&lt;TabDemo1&gt;() } } } } }.lparams(width = matchParent) { // 6 height = matchParent } } 分别解释： 竖直布局。本质是 LinearLayout，并且 orientation 的值为 vertical。但是水平方向的就没有 vetialLayout 这种可以直接使用的了，需要自己写明orientation。 创建一个 listview。 给这个 listview 添加 adapter。这里简单实用 ArrayAdapter。 添加 OnItemClickListener。object : AdapterView.OnItemClickListener 用来创建实现某个接口的匿名类。 startActivity()，是Anko的语法糖。startActivity(SourceActivity.this, DestActivity.class)可以直接简化为 startActivity()。简单了不少。 在 lparams 中设置 layout params 相关的内容。默认的都是 wrap content。这个设置为宽、高都为 match parent。 用 Fragment 写一个 Tab 布局 下面要开发的是一个日记 App。一共有三个 tab，第一个是日记列表，第二个 tab 是写日记，第三个 tab 可以设置一些字体大小等（这里只用来占位，不做实现）。 每一个 tab 都用一个 Fragment 来展示内容。这三个 tab 分别 HomeListFragment, DetailFragment,DiarySettingsFragment。 这三个 fragment 都在一个叫做 TabDemo1 的托管 Activity 里。 现在就从这个托管 activity：TabDemo1 开始。这里我们不使用默认的 ActionBar，而是用完全自定义的方式来写一个我们自己的 action bar。所以需要把界面设定为全屏模式。设置全屏的模式的方法有很多，我们用设置 style 的方式来实现。 &lt;style name=&quot;AppTheme.NoActionBar&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt; &lt;/style&gt; 之后把这个 style 应用在 activity 在 AndroidManifest.xml 配置中。 这个时候这个托管 activity 的界面布局就是一个完全的白板了。这个白板现在要分为上中下三部分。上部为我们自定义的 action bar，最下面的是 tab bar，剩下的部分就是每个 tab 的内容的fragment。 我们来看一下这个布局应该怎么写： // 1 relativeLayout { id = ID_RELATIVELAYOUT backgroundColor = Color.LTGRAY // 2 linearLayout { id = ID_TOP_BAR backgroundColor = ContextCompat.getColor(ctx, R.color.colorPrimary) orientation = LinearLayout.HORIZONTAL titleTextView = textView { text = &quot;Some Title&quot; textSize = 16f textColor = Color.WHITE gravity = Gravity.CENTER_HORIZONTAL or Gravity.CENTER_VERTICAL }.lparams { width = dip(0) height = matchParent weight = 1f } }.lparams { width = matchParent height = dip(50) alignParentTop() } // 3 linearLayout { id = ID_BOTTOM_TAB_BAR orientation = LinearLayout.HORIZONTAL backgroundColor = Color.WHITE // 4 homeListTab = weightTextView { text = &quot;List&quot; normalDrawable = resources.getDrawable(R.mipmap.tab_my_normal) selectedDrawable = resources.getDrawable(R.mipmap.tab_my_pressed) onClick { tabClick(0) } } detailTab = weightTextView { text = &quot;Detail&quot; normalDrawable = resources.getDrawable(R.mipmap.tab_channel_normal) selectedDrawable = resources.getDrawable(R.mipmap.tab_channel_pressed) onClick { tabClick(1) } } settingsTab = weightTextView { text = &quot;Settings&quot; normalDrawable = resources.getDrawable(R.mipmap.tab_better_normal) selectedDrawable = resources.getDrawable(R.mipmap.tab_better_pressed) onClick { tabClick(2) } } }.style { // 5 view -&gt; when (view) { is TextView -&gt; { view.padding = dip(5) view.compoundDrawablePadding = dip(3) view.textSize = 10f view.gravity = Gravity.CENTER } else -&gt; { } } }.lparams { height = dip(50) width = matchParent alignParentBottom() } // 6 fragmentContainer = frameLayout { id = ID_FRAMELAYOUT backgroundColor = Color.GREEN }.lparams { below(ID_TOP_BAR) above(ID_BOTTOM_TAB_BAR) width = matchParent height = matchParent } } 前文的例子用了一个 verticalLayout, 这里用的是 relativeLayout 的布局。这里是自定义 action bar。使用换一个 linearLayout。如前所述，要横向布局 linear layout就需要单独的指定 orientation：orientation =LinearLayout.HORIZONTAL。这里比较简单，只有一个显示 title 的 textView。 这里需要注意 gravity = Gravity.CENTER_HORIZONTAL or Gravity.CENTER_VERTICAL 可以直接写成 gravity = Gravity.CENTER。这里是为了突出or的用法。Kotlin 里的 or就是 java 的 | 操作符的作用。 这部分的布局是 tab bar。 这里用的是 weightTextView 而不是 textView。后面会详细的讲解这一部分。给 tab bar 添加 style。此 style 不是彼 style。这个 style，会遍历 tab bar 的 linear layout 内部的全部的 view，然后根据 when 表达式匹配对应的规则，之后给对应于规则的 view 设置相应的属性。比如，这里会用 when 语句查看 view 是否为 textView，如果是的话就给这个 view 设置 padding、drawable padding、text size 以及 gravity 属性。tab bar 的 linear layout有三个 text view，所以他们都会被设置这些属性。每一个 tab 的内容展示用 fragment 就是这里了。准确的说是 fragment 的 container。这个 container 是一个 framelayout。在 action bar 之下，在 tab bar 之上。在布局的时候有 below(ID_TOP_BAR), above(ID_BOTTOM_TAB_BAR)。ID_TOP_BAR 和 ID_BOTTOM_TAB_BAR 就分别是 action bar 和 tab bar 的 id 值。这些 id 值自由设定。另外，在 java 写的时候常用的 findViewById() 方法在 Kotlin 和 Anko 中可以改为的find(ID_FRAMELAYOUT)。不见得简单，但是增加了类型安全。不用再强制类型转换。也不用担心相关的错误再发生。 上文第4点用到了 weightTextView。这是一个自定义的 view。在 Anko 布局中，可以根据自己的需要自定义各种各样的 view。但是，需要经过一个小小的处理之后才可以使用到 Anko 的布局中。这个小小的处理就叫做扩展。下面看看如何给 Anko 添加 weightTextView 扩展的。 首先自定义一个 view：WeightTextView。 class WeightTextView(context: Context) : TextView(context) { var normalDrawable: Drawable? = null var selectedDrawable: Drawable? = null init { var layoutParams = LinearLayout.LayoutParams(dip(50), LinearLayout.LayoutParams.MATCH_PARENT, 1f) layoutParams.weight = 1f this.layoutParams = layoutParams } override fun setSelected(selected: Boolean) { super.setSelected(selected) if (selected) { this.backgroundColor = ContextCompat.getColor(context, R.color.textGray) this.textColor = ContextCompat.getColor(context, R.color.textYellow) if (selectedDrawable != null) { this.setCompoundDrawablesWithIntrinsicBounds(null, selectedDrawable, null, null) } } else { this.backgroundColor = ContextCompat.getColor(context, android.R.color.transparent) this.textColor = ContextCompat.getColor(context, R.color.textGray) if (normalDrawable != null) { this.setCompoundDrawablesWithIntrinsicBounds(null, normalDrawable, null, null) } } } } 附加解释：方法 setSelected() 是被迫添加的。在使用 Anko，相当于使用代码开发 Android 布局的时候 selector 不起作用。只好把点击后的高亮效果写在自定义的 text view 里。 下面看看如何扩展 Anko，来使用我们上面的自定义 view。 public inline fun ViewManager.weightTextView() = weightTextView {} public inline fun ViewManager.weightTextView(init: WeightTextView.() -&gt; Unit) = ankoView({ WeightTextView(it) }, init) 这部分涉及到的语法内容可以参考官网。这里简单介绍一下。拿官网的例子说一下： class HTML { fun body() { ... } } 现在有这么一个 HTML 类，那么调用的时候可以这样： html { body() } 在这么一个 lambda 表达式里就可以直接这样调用 HTML 类的方法了，中间的过程是怎么样的呢 fun html(init: HTML.() -&gt; Unit): HTML { val html = HTML() // create the receiver object html.init() return html } 其实灰常的简单呢。在方法 html() 里，参数是一个 HTML 类的扩展方法，并且此方法无参，返回 Unit(java的void)。 在方法执行的过程中，首先初始化了 HTML。之后调用了这个作为参数传入的扩展方法。在具体调用 html() 方法的时候，可以只简单写一个 lambda 表达式作为传入的 HTML 扩展方法。既然是一个类的扩展方法，那当然可以调用这个类内部的方法了。 为了帮助理解，这里给出一个参数是方法的方法： fun main(args: Array&lt;String&gt;) { calling(&quot;yo&quot;) { p -&gt; println(&quot;method called $p&quot;) } calling(&quot;yoyo&quot;, ::called) } fun calling(param: String, func: (String) -&gt; Unit) { func(param) } fun called(p: String) { println(&quot;output string $p&quot;) } 第一个是用 lambda 表达式作为传入方法，第二个是已经定义好的一个方法作为传入方法。 Fragment 的处理本文中的重点在于使用 Anko 做布局，具体的逻辑处理 java 写和 Kotlin 写没有什么区别。这里只简单介绍一下。 为了保证兼容，这里使用 Support v4 来处理 Fragment 的显示等操作。在 activity 的一开始就把需要的 fragemnt 都加载进来。 fun prepareTabFragments() { val fm = supportFragmentManager homeListFragment = HomeListFragment.newInstance() fm.beginTransaction() .add(ID_FRAMELAYOUT, homeListFragment) .commit() detailFragment = DetailFragment.newInstance(null) detailFragment?.modelChangeListener = homeListFragment fm.beginTransaction() .add(ID_FRAMELAYOUT, detailFragment) .commit() settingsFragment = DiarySettingsFragment.newInstance() fm.beginTransaction() .add(ID_FRAMELAYOUT, settingsFragment) .commit() } 每一个 tab 项被点击的时候的处理： fun tabClick(index: Int) { info(&quot;index is $index&quot;) val ft = supportFragmentManager.beginTransaction() ft.hide(homeListFragment) ft.hide(detailFragment) ft.hide(settingsFragment) // unselect all textviews homeListTab?.isSelected = false detailTab?.isSelected = false settingsTab?.isSelected = false when (index) { 0 -&gt; { homeListTab?.isSelected = true ft.show(homeListFragment) } 1 -&gt; { detailTab?.isSelected = true ft.show(detailFragment) } 2 -&gt; { settingsTab?.isSelected = true ft.show(settingsFragment) } else -&gt; { } } ft.commit() } 分别开始每一个 Fragment在开始之前需要考虑一个很严重的事情：数据存在什么地方。本来应该是 SQLite 或者存在云上的。存在云裳就可以实现同一个账号登录在任何地方都可以同步到同样的内容。这里只简单模拟，存放在 app 的内存里。存放在 Application 派生类 AnkoApplication 的静态属性 diaryDataSource 里。diaryDataSource 是一个 ArrayList 一样的列表。 class AnkoApplication : Application() { override fun onCreate() { super.onCreate() } companion object { var diaryDataSource = mutableListOf&lt;DiaryModel&gt;() } } 第一个 tab，HomeListFragmentHomeListFragment 类作为第一个 tab 内容展示 fragment，用来显示全部的日记列表的布局就非常简单了，和我们前面的例子没有什么太大的差别。就是在一个 verticalLayout 里放一个 list view。这个 list view 的 data source 只需要一个列表。 // 1 var view = with(ctx) { verticalLayout { backgroundColor = Color.WHITE listView = listView { adapter = ArrayAdapter&lt;DiaryModel&gt;(ctx, android.R.layout.simple_list_item_1, AnkoApplication.diaryDataSource) onItemClick { adapterView, view, i, l -&gt; toast(&quot;clicked index: $i, content: ${AnkoApplication.diaryDataSource[i].toString()}&quot;) } } // 2 emptyTextView = textView { text = resources.getString(R.string.list_view_empty) textSize = 30f gravity = Gravity.CENTER }.lparams { width = matchParent height = matchParent } } } // 3 listView?.emptyView = emptyTextView return view 在 activity 里的布局可以直接写 vertical{}，但是在 fragment 里不可以这样。直接写 vertical{} 就已经把这个layout添加到父 view 上了，这 fragment 里是不行的。在 fragment 里需要创建一个单独的 view，并返回。用 with 语句来创建这样一个单独的 view。在 vertial layout 里添加了一个 textview。上面一步创建的 textview 作为 list view 没有数据的时候显示的 empty view 来使用。第二个 tab，DetailFragment日记的内容包括，日记 title，日记本身的内容还有日记的日期。 所以布局上就包括日记的 title 内容输入用的 EditText 以及为了说明用的 text view，还有 edit text 里的 hint。最后还有一个选择日期的控件。 return with(ctx) { verticalLayout { padding = dip(10) backgroundColor = Color.WHITE textView(&quot;TITLE&quot;) { }.lparams(width = matchParent) titleEditText = editText { hint = currentDateString() lines = 1 }.lparams(width = matchParent) { topMargin = dip(5) } textView(&quot;CONTENT&quot;) { }.lparams(width = matchParent) { topMargin = dip(15) } contentEditText = editText { hint = &quot;what&apos;s going on...&quot; setHorizontallyScrolling(false) }.lparams(width = matchParent) { // height = matchParent topMargin = dip(5) } button(R.string.button_select_time) { gravity = Gravity.CENTER onClick { val fm = activity.supportFragmentManager var datePicker = DatePickerFragment.newInstance(diaryModel?.date) datePicker.setTargetFragment(this@DetailFragment, DetailFragment.REQUEST_DATE) datePicker.show(fm, &quot;date&quot;) } } // * button(R.string.button_detail_ok) { onClick { v -&gt; println(&quot;ok button clicked&quot;) try { var model = diaryModel!! model.title = titleEditText?.text.toString() model.content = contentEditText?.text.toString() AnkoApplication.diaryDataSource.add(model) modelChangeListener?.modelChanged() toast(R.string.model_saved_ok) } catch(e: Exception) { Log.d(&quot;##DetailFragment&quot;, &quot;error: ${e.toString()}&quot;) toast(R.string.model_save_error) } } }.lparams { topMargin = dip(10) width = matchParent } }.style { view -&gt; when (view) { is Button -&gt; { view.gravity = Gravity.CENTER } is TextView -&gt; { view.gravity = Gravity.LEFT view.textSize = 20f view.textColor = Color.DKGRAY } } } } 需要注意打星号的地方。按钮在点击之后会弹出一个 dialog fragment 来显示日期 view。用户可以在这个日期 view 里选择相应的日期。但是，如何从日期 dialog fragment 传递选择的日期给 DetailFragment 呢？这里就涉及到两个 fragment 之间传递数据的问题。 选择日期的dialog fragment是DatePickerFragment。 var pickerView = DatePicker(activity) pickerView.calendarViewShown = false pickerView.layoutParams = ViewGroup.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT) pickerView.init(year, month, day) { view, year, month, day -&gt; mDate = GregorianCalendar(year, month, day).time arguments.putSerializable(EXTRA_DATE, mDate) } return AlertDialog.Builder(activity) .setView(pickerView) .setTitle(R.string.date_picker_title) .setPositiveButton(R.string.picker_button_ok) { dialog, which -&gt; toast(&quot;hello world!&quot;) sendResult(Activity.RESULT_OK) }.create() 首先 DatePickerFragment 要继承 DialogFragment 之后 override 方法 onCreateDialog(savedInstanceState: Bundle)。 在这个方法里使用上面代码创建一个包含日期选择器的 dialog。 在选择日期的时候，会触发 DatePicker 的 OnDateChangedListener 接口的 onDateChanged 方法。我们在这个方法里记录选择好的日期数据，在dialog的positive按钮点击之后把这个数据发送给 DetailFragment。 那么怎么发送呢？使用 target fargment 方法。在 detail fragment 弹出 dialog fragment 的时候，把 detail fragment 设置为 target fragment。 button(R.string.button_select_time) { gravity = Gravity.CENTER onClick { val fm = activity.supportFragmentManager var datePicker = DatePickerFragment.newInstance(diaryModel?.date) // * datePicker.setTargetFragment(this@DetailFragment, DetailFragment.REQUEST_DATE) datePicker.show(fm, &quot;date&quot;) } } 在标星下面的一行代码中。datePicker.setTargetFragment(this@DetailFragment,DetailFragment.REQUEST_DATE)将DetailFragment设定为target fragment，并且指定REQUEST_DATE这code，为以后取出数据使用。 companion object Factory { val REQUEST_DATE = 0` } 在 positive 按钮点击之后执行方法 sendResult 回传数据 private fun sendResult(resultCode: Int) { if (targetFragment == null) return var i = Intent() i.putExtra(EXTRA_DATE, mDate) // * targetFragment.onActivityResult(targetRequestCode, resultCode, i) } 调用 targetFragment 的 onActivityResult() 方法来回传日期数据。 在 DetailFragment 中通过 override 方法 onActivityResult() 来接收数据。 override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) { if (resultCode != Activity.RESULT_OK) { return } if (requestCode != REQUEST_DATE) { return } var date = data?.getSerializableExtra(DatePickerFragment.EXTRA_DATE) as Date diaryModel?.date = date } 日期数据传输这部分到这里结束。 全文也可以在这里画上一个句点了。以上还有很多关于 Anko 没有使用的地方。Anko 也是可以实现代码界面分离的。继承 AnkoComponent 可以写出独立的布局文件，并且可以用 anko preview 插件来预览界面效果。就拿 setting 这个 tab 的 fragment 来举例：首先定义一个独立的布局文件: class SettingsUI&lt;T&gt; : AnkoComponent&lt;T&gt; { override fun createView(ui: AnkoContext&lt;T&gt;) = with(ui) { verticalLayout { backgroundColor = ContextCompat.getColor(ctx, R.color.SnowWhite) textView { text = resources.getString(R.string.settings_title) } button(&quot;activity with the same `AnkoComponent`&quot;) { id = ID_BUTTON } } } companion object Factory { public val ID_BUTTON = 101 } } 把这个布局文件用在 DiarySettingsFragment 上： override fun onCreateView(inflater: LayoutInflater?, container: ViewGroup?, val view = SettingsUI&lt;DiarySettingsFragment&gt;().createView(AnkoContext.create(ctx, DiarySettingsFragment())) return view } 然后这个布局还可以用在我们刚刚创建的 TempActivity 上： override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) SettingsUI&lt;TempActivity&gt;().setContentView(this) val button = find&lt;Button&gt;(SettingsUI.ID_BUTTON) button.text = &quot;you are in `TempActivity`, CLICK!&quot; button.onClick { toast(&quot;${TempActivity::class.java.simpleName}&quot;) } } Activity 上使用就简单很多了，只需要这么一句 SettingsUI().setContentView(this)。","link":"/2018/06/05/Kotlin 中使用 Anko 编写布局/"}],"tags":[],"categories":[]}