
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Kotlin 中使用 Anko 编写布局 | 肖坤的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="使用 Kotlin 开发已经开发两个项目了。说大幅度的减少了 Java 代码一点不夸张。用 Java 的时候动不动就 new 一个 OnClickListener() 匿名类，动不动就类型转换的地方都可以省下很多。更不用说特殊的地方使用 data class 更是少些不知道多少代码。 Jetbrains 给 Android 带来的不仅是 Kotlin，还有 Anko。从 Anko 的官方说明来看这">
<meta property="og:type" content="article">
<meta property="og:title" content="Kotlin 中使用 Anko 编写布局">
<meta property="og:url" content="http://hellokk.cc/2018/06/05/Kotlin 中使用 Anko 编写布局/index.html">
<meta property="og:site_name" content="肖坤的博客">
<meta property="og:description" content="使用 Kotlin 开发已经开发两个项目了。说大幅度的减少了 Java 代码一点不夸张。用 Java 的时候动不动就 new 一个 OnClickListener() 匿名类，动不动就类型转换的地方都可以省下很多。更不用说特殊的地方使用 data class 更是少些不知道多少代码。 Jetbrains 给 Android 带来的不仅是 Kotlin，还有 Anko。从 Anko 的官方说明来看这">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-06-05T12:32:14.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Kotlin 中使用 Anko 编写布局">
<meta name="twitter:description" content="使用 Kotlin 开发已经开发两个项目了。说大幅度的减少了 Java 代码一点不夸张。用 Java 的时候动不动就 new 一个 OnClickListener() 匿名类，动不动就类型转换的地方都可以省下很多。更不用说特殊的地方使用 data class 更是少些不知道多少代码。 Jetbrains 给 Android 带来的不仅是 Kotlin，还有 Anko。从 Anko 的官方说明来看这">
  
    <link rel="alternative" href="/atom.xml" title="肖坤的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
</head>
<body>
<div id="container">
  <div id="wrap">
    <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">肖坤的博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" class="search-form">
          <input type="search" name="word" maxlength="20" class="search-form-input" placeholder="Search">
          <input type="submit" value="" class="search-form-submit">
          <input name=tn type=hidden value="bds">
          <input name=cl type=hidden value="3">
          <input name=ct type=hidden value="2097152">
          <input type="hidden" name="si" value="hellokk.cc">
        </form>
      </div>
    </div>
  </div>
</header>
    <div class="outer">
      <section id="main"><article id="post-Kotlin 中使用 Anko 编写布局" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/05/Kotlin 中使用 Anko 编写布局/" class="article-date">
  <time datetime="2018-06-05T12:32:14.000Z" itemprop="datePublished">2018-06-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Kotlin 中使用 Anko 编写布局
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>使用 Kotlin 开发已经开发两个项目了。说大幅度的减少了 Java 代码一点不夸张。用 Java 的时候动不动就 new 一个 OnClickListener() 匿名类，动不动就类型转换的地方都可以省下很多。更不用说特殊的地方使用 data class 更是少些不知道多少代码。</p>
<p>Jetbrains 给 Android 带来的不仅是 Kotlin，还有 Anko。从 Anko 的官方说明来看这是一个雄心勃勃的要代替 XML 写 Layout 的新的开发方式。 Anko 最重要的一点是引入了 DSL（Domain Specific Language）的方式开发 Android 界面布局。当然，本质是代码实现布局。不过使用 Anko 完全不用经历 Java 纯代码写 Android 的痛苦。因为本身是来自 Kotlin 的，所以自然的使用这种方式开发就具有了： </p>
<ul>
<li>类型安全，不再需要那么多的 findById() 之后的类型转换。 </li>
<li>null 安全，Kotlin 里，如果一个变量用？表示为可空，并且使用？之后再调用的时候，即使变量为空也不会引发异常。 </li>
<li>无需设备解析 XML，因为 Anko 本质是代码实现的界面和布局，所以省去了这些麻烦。 </li>
<li>代码复用，可以通过继承 AnkoComponent 的方式实现代码复用。XML 布局是每一个 Activity，每一个 View 各自专属一个，代码复用比较少。</li>
</ul>
<p>来一个例子看一下：</p>
<ol>
<li>使用 XML </li>
</ol>
<pre><code class="xml"><span class="tag">&lt;<span class="name">RelativeLayout</span>&gt;</span>

    <span class="tag">&lt;<span class="name">TextView</span></span>
<span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/sample_text_view"</span></span>
<span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span>
<span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span>
<span class="tag">        <span class="attr">android:layout_alignParentTop</span>=<span class="string">"true"</span></span>
<span class="tag">        <span class="attr">android:text</span>=<span class="string">"Sample text view"</span></span>
<span class="tag">        <span class="attr">android:textSize</span>=<span class="string">"25sp"</span> /&gt;</span>

    <span class="tag">&lt;<span class="name">Button</span></span>
<span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/sample_button"</span></span>
<span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span>
<span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span>
<span class="tag">        <span class="attr">android:layout_below</span>=<span class="string">"@+id/sample_text_view"</span></span>
<span class="tag">        <span class="attr">android:text</span>=<span class="string">"Sample button"</span> /&gt;</span>

<span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span>
</code></pre>
<ol>
<li><p>使用 Anko</p>
<pre><code>relativeLayout {
    val textView = textView(&quot;Sample text view&quot;) {
        textSize = 25f
    }.lparams {
        width = matchParent
        alignParentTop()
    }

    button(&quot;Sample button&quot;).lparams {
        width = matchParent
        below(textView)
    }
}
</code></pre></li>
</ol>
<p>使用前需要在在 <code>build.gradle</code> 里添加下面的代码：</p>
<pre><code>dependencies {
    compile &apos;org.jetbrains.anko:anko-sdk15:0.8.3&apos; // sdk19, sdk21, sdk23 are also available
    compile &apos;org.jetbrains.anko:anko-support-v4:0.8.3&apos; // In case you need support-v4 bindings
    compile &apos;org.jetbrains.anko:anko-appcompat-v7:0.8.3&apos; // For appcompat-v7 bindings
}
</code></pre><p>写一个 ListView 热身<br>首先创建一个 ListView 的 item 点击之后跳转的 activity。这里叫做 TabDemo1。</p>
<p>现在就创建这个 listview，并在 listview 的 item 点击之后调转到相应的 activity 去。<br>这个 listview 非常简单，只在一个竖直的布局中放置，并且宽度和高度都是填满竖直<br>布局。</p>
<pre><code>// 1
verticalLayout {
    padding = dip(16)
    // 2
    val list = listView() {
        // 3
        adapter = ArrayAdapter&lt;String&gt;(this@MainActivity, android.R.layout.simple_list_item_1, items)
        // 4
        onItemClickListener = object : AdapterView.OnItemClickListener {
            override fun onItemClick(parent: AdapterView&lt;*&gt;?, v: View?, position: Int, id: Long) {
                when (position) {
                    0 -&gt; {
                        // 5
                        startActivity&lt;TabDemo1&gt;()
                    }
                }
            }
        }
    }.lparams(width = matchParent) { // 6
        height = matchParent
    }
}
</code></pre><p>分别解释： </p>
<ol>
<li>竖直布局。本质是 LinearLayout，并且 orientation 的值为 vertical。但是<br>水平方向的就没有 vetialLayout 这种可以直接使用的了，需要自己写明orientation。 </li>
<li>创建一个 listview。 </li>
<li>给这个 listview 添加 adapter。这里简单实用 ArrayAdapter<string>。 </string></li>
<li>添加 OnItemClickListener。object : AdapterView.OnItemClickListener 用来<br>创建实现某个接口的匿名类。 </li>
<li>startActivity<tabdemo1>()，是Anko的语法糖。startActivity(SourceActivity.this, DestActivity.class)<br>可以直接简化为 startActivity<destactivity>()。简单了不少。 </destactivity></tabdemo1></li>
<li>在 lparams 中设置 layout params 相关的内容。默认的都是 wrap content。这个设置为<br>宽、高都为 match parent。</li>
</ol>
<p>用 Fragment 写一个 Tab 布局</p>
<p>下面要开发的是一个日记 App。一共有三个 tab，第一个是日记列表，第二个 tab 是写日记，第三个 tab 可以设置一些字体大小等（这里只用来占位，不做实现）。</p>
<p>每一个 tab 都用一个 Fragment 来展示内容。这三个 tab 分别 HomeListFragment, DetailFragment,DiarySettingsFragment。 这三个 fragment 都在一个叫做 TabDemo1 的托管 Activity 里。</p>
<p>现在就从这个托管 activity：TabDemo1 开始。这里我们不使用默认的 ActionBar，而是用完全自定义的方式来写一个我们自己的 action bar。所以需要把界面设定为全屏模式。设置全屏的模式的方法有很多，我们用设置 style 的方式来实现。</p>
<pre><code>&lt;style name=&quot;AppTheme.NoActionBar&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt;
&lt;/style&gt;
</code></pre><p>之后把这个 style 应用在 activity 在 AndroidManifest.xml 配置中。</p>
<p>这个时候这个托管 activity 的界面布局就是一个完全的白板了。这个白板现在要分为上中下三部分。上部为我们自定义的 action bar，最下面的是 tab bar，剩下的部分就是每个 tab 的内容的fragment。</p>
<p>我们来看一下这个布局应该怎么写：</p>
<pre><code>// 1
relativeLayout {
    id = ID_RELATIVELAYOUT

    backgroundColor = Color.LTGRAY

    // 2
    linearLayout {
        id = ID_TOP_BAR
        backgroundColor = ContextCompat.getColor(ctx, R.color.colorPrimary)
        orientation = LinearLayout.HORIZONTAL

        titleTextView = textView {
            text = &quot;Some Title&quot;
            textSize = 16f
            textColor = Color.WHITE
            gravity = Gravity.CENTER_HORIZONTAL or Gravity.CENTER_VERTICAL
        }.lparams {
            width = dip(0)
            height = matchParent
            weight = 1f
        }
    }.lparams {
        width = matchParent
        height = dip(50)
        alignParentTop()
    }

    // 3
    linearLayout {
        id = ID_BOTTOM_TAB_BAR
        orientation = LinearLayout.HORIZONTAL
        backgroundColor = Color.WHITE

        // 4
        homeListTab = weightTextView {
            text = &quot;List&quot;
            normalDrawable = resources.getDrawable(R.mipmap.tab_my_normal)
            selectedDrawable = resources.getDrawable(R.mipmap.tab_my_pressed)
            onClick { tabClick(0) }
        }

        detailTab = weightTextView {
            text = &quot;Detail&quot;
            normalDrawable = resources.getDrawable(R.mipmap.tab_channel_normal)
            selectedDrawable = resources.getDrawable(R.mipmap.tab_channel_pressed)
            onClick { tabClick(1) }
        }

        settingsTab = weightTextView {
            text = &quot;Settings&quot;
            normalDrawable = resources.getDrawable(R.mipmap.tab_better_normal)
            selectedDrawable = resources.getDrawable(R.mipmap.tab_better_pressed)
            onClick { tabClick(2) }
        }

    }.style { // 5
        view -&gt;
        when (view) {
            is TextView -&gt; {
                view.padding = dip(5)
                view.compoundDrawablePadding = dip(3)
                view.textSize = 10f
                view.gravity = Gravity.CENTER
            }
            else -&gt; {
            }
        }
    }.lparams {
        height = dip(50)
        width = matchParent
        alignParentBottom()
    }

    // 6
    fragmentContainer = frameLayout {
        id = ID_FRAMELAYOUT
        backgroundColor = Color.GREEN
    }.lparams {
        below(ID_TOP_BAR)
        above(ID_BOTTOM_TAB_BAR)
        width = matchParent
        height = matchParent
    }
}
</code></pre><p>前文的例子用了一个 verticalLayout, 这里用的是 relativeLayout 的布局。<br>这里是自定义 action bar。使用换一个 linearLayout。如前所述，要横向布局 linear layout<br>就需要单独的指定 orientation：orientation =LinearLayout.HORIZONTAL。这里比较简单，只有一个显示 title 的 textView。</p>
<p>这里需要注意 gravity = Gravity.CENTER_HORIZONTAL or Gravity.CENTER_VERTICAL<br> 可以直接写成 gravity = Gravity.CENTER。这里是为了突出or的用法。Kotlin 里的 or<br>就是 java 的 | 操作符的作用。</p>
<p>这部分的布局是 tab bar。</p>
<p>这里用的是 weightTextView 而不是 textView。后面会详细的讲解这一部分。<br>给 tab bar 添加 style。此 style 不是彼 style。这个 style，会遍历 tab bar 的 linear layout 内部的全部的 view，然后根据 when 表达式匹配对应的规则，之后给对应于规则的 view 设置相应的属性。比如，这里会用 when 语句查看 view 是否为 textView，如果是的话就给这个 view 设置 padding、drawable padding、text size 以及 gravity 属性。tab bar 的 linear layout有三个 text view，所以他们都会被设置这些属性。<br>每一个 tab 的内容展示用 fragment 就是这里了。准确的说是 fragment 的 container。<br>这个 container 是一个 framelayout。在 action bar 之下，在 tab bar 之上。在布局的时候有 below(ID_TOP_BAR), above(ID_BOTTOM_TAB_BAR)。ID_TOP_BAR 和 ID_BOTTOM_TAB_BAR 就分别是 action bar 和 tab bar 的 id 值。这些 id 值自由设定。<br>另外，在 java 写的时候常用的 findViewById() 方法在 Kotlin 和 Anko 中可以改为的find<framelayout>(ID_FRAMELAYOUT)。不见得简单，但是增加了类型安全。不用再强制类型转换。也不用担心相关的错误再发生。</framelayout></p>
<p>上文第4点用到了 weightTextView。这是一个自定义的 view。在 Anko 布局中，可以根据自己的需要自定义各种各样的 view。但是，需要经过一个小小的处理之后才可以使用到 Anko 的布局中。这个小小的处理就叫做扩展。下面看看如何给 Anko 添加 weightTextView 扩展的。</p>
<p>首先自定义一个 view：WeightTextView。</p>
<pre><code>class WeightTextView(context: Context) : TextView(context) {
        var normalDrawable: Drawable? = null
        var selectedDrawable: Drawable? = null

        init {
            var layoutParams = LinearLayout.LayoutParams(dip(50),
                    LinearLayout.LayoutParams.MATCH_PARENT, 1f)
            layoutParams.weight = 1f
            this.layoutParams = layoutParams
        }

        override fun setSelected(selected: Boolean) {
            super.setSelected(selected)

            if (selected) {
                this.backgroundColor = ContextCompat.getColor(context, R.color.textGray)
                this.textColor = ContextCompat.getColor(context, R.color.textYellow)

                if (selectedDrawable != null) {
                    this.setCompoundDrawablesWithIntrinsicBounds(null, selectedDrawable, null, null)
                }
            } else {
                this.backgroundColor = ContextCompat.getColor(context, android.R.color.transparent)
                this.textColor = ContextCompat.getColor(context, R.color.textGray)
                if (normalDrawable != null) {
                    this.setCompoundDrawablesWithIntrinsicBounds(null, normalDrawable, null, null)
                }
            }
        }
    }
</code></pre><p>附加解释：<br>方法 setSelected() 是被迫添加的。在使用 Anko，相当于使用代码开发 Android 布局的时候 selector 不起作用。只好把点击后的高亮效果写在自定义的 text view 里。</p>
<p>下面看看如何<strong>扩展</strong> Anko，来使用我们上面的自定义 view。</p>
<pre><code>public inline fun ViewManager.weightTextView() = weightTextView {}
public inline fun ViewManager.weightTextView(init: WeightTextView.() -&gt; Unit) = ankoView({ WeightTextView(it) }, init)
</code></pre><p>这部分涉及到的语法内容可以参考官网。<br>这里简单介绍一下。拿官网的例子说一下：</p>
<pre><code>class HTML {
    fun body() { ... }
}
</code></pre><p>现在有这么一个 HTML 类，那么调用的时候可以这样：</p>
<pre><code>html {       
    body()  
}
</code></pre><p>在这么一个 lambda 表达式里就可以直接这样调用 HTML 类的方法了，中间的过程是怎么样的呢</p>
<pre><code>fun html(init: HTML.() -&gt; Unit): HTML {
    val html = HTML()  // create the receiver object
    html.init()        
    return html
}
</code></pre><p>其实灰常的简单呢。在方法 html() 里，参数是一个 HTML 类的扩展方法，并且此方法无参，返回 Unit(java的void)。</p>
<p>在方法执行的过程中，首先初始化了 HTML。之后调用了这个作为参数传入的扩展方法。在具体调用 html() 方法的时候，可以只简单写一个 lambda 表达式作为传入的 HTML 扩展方法。既然是一个类的扩展方法，那当然可以调用这个类内部的方法了。</p>
<p>为了帮助理解，这里给出一个参数是方法的方法：</p>
<pre><code>fun main(args: Array&lt;String&gt;) {
    calling(&quot;yo&quot;) { p -&gt;
        println(&quot;method called $p&quot;)
    }

    calling(&quot;yoyo&quot;, ::called)
}

fun calling(param: String, func: (String) -&gt; Unit) {
    func(param)
}

fun called(p: String) {
    println(&quot;output string $p&quot;)
}
</code></pre><p>第一个是用 lambda 表达式作为传入方法，第二个是已经定义好的一个方法作为传入方法。</p>
<p>Fragment 的处理<br>本文中的重点在于使用 Anko 做布局，具体的逻辑处理 java 写和 Kotlin 写没有什么区别。这里只简单介绍一下。</p>
<p>为了保证兼容，这里使用 Support v4 来处理 Fragment 的显示等操作。在 activity 的一开始就把需要的 fragemnt 都加载进来。</p>
<pre><code>fun prepareTabFragments() {
    val fm = supportFragmentManager
    homeListFragment = HomeListFragment.newInstance()
    fm.beginTransaction()
            .add(ID_FRAMELAYOUT, homeListFragment)
            .commit()
    detailFragment = DetailFragment.newInstance(null)
    detailFragment?.modelChangeListener = homeListFragment
    fm.beginTransaction()
            .add(ID_FRAMELAYOUT, detailFragment)
            .commit()
    settingsFragment = DiarySettingsFragment.newInstance()
    fm.beginTransaction()
            .add(ID_FRAMELAYOUT, settingsFragment)
            .commit()
}
</code></pre><p>每一个 tab 项被点击的时候的处理：</p>
<pre><code>fun tabClick(index: Int) {
    info(&quot;index is $index&quot;)
    val ft = supportFragmentManager.beginTransaction()
    ft.hide(homeListFragment)
    ft.hide(detailFragment)
    ft.hide(settingsFragment)

    // unselect all textviews
    homeListTab?.isSelected = false
    detailTab?.isSelected = false
    settingsTab?.isSelected = false

    when (index) {
        0 -&gt; {
            homeListTab?.isSelected = true
            ft.show(homeListFragment)
        }
        1 -&gt; {
            detailTab?.isSelected = true
            ft.show(detailFragment)
        }
        2 -&gt; {
            settingsTab?.isSelected = true
            ft.show(settingsFragment)
        }
        else -&gt; {

        }
    }

    ft.commit()
}
</code></pre><p>分别开始每一个 Fragment<br>在开始之前需要考虑一个很严重的事情：数据存在什么地方。本来应该是 SQLite 或者存在云上的。存在云裳就可以实现同一个账号登录在任何地方都可以同步到同样的内容。这里只简单模拟，存放在 app 的内存里。存放在 Application 派生类 AnkoApplication 的<br>静态属性 diaryDataSource 里。diaryDataSource 是一个 ArrayList 一样的列表。</p>
<pre><code>class AnkoApplication : Application() {

    override fun onCreate() {
        super.onCreate()
    }

    companion object {
        var diaryDataSource = mutableListOf&lt;DiaryModel&gt;()
    }
}
</code></pre><p>第一个 tab，HomeListFragment<br>HomeListFragment 类作为第一个 tab 内容展示 fragment，用来显示全部的日记列表的布局就非常简单了，和我们前面的例子没有什么太大的差别。就是在一个 verticalLayout 里放一个 list view。这个 list view 的 data source 只需要一个列表。</p>
<pre><code>// 1
var view = with(ctx) {
    verticalLayout {
        backgroundColor = Color.WHITE

        listView = listView {
            adapter = ArrayAdapter&lt;DiaryModel&gt;(ctx,
                    android.R.layout.simple_list_item_1,
                    AnkoApplication.diaryDataSource)

            onItemClick { adapterView, view, i, l -&gt;
                toast(&quot;clicked index: $i, content: ${AnkoApplication.diaryDataSource[i].toString()}&quot;)
            }
        }

        // 2
        emptyTextView = textView {
            text = resources.getString(R.string.list_view_empty)
            textSize = 30f
            gravity = Gravity.CENTER
        }.lparams {
            width = matchParent
            height = matchParent
        }
    }
}
// 3
listView?.emptyView = emptyTextView

return view
</code></pre><p>在 activity 里的布局可以直接写 vertical{}，但是在 fragment 里不可以这样。直接写 vertical{} 就已经把这个layout添加到父 view 上了，这 fragment 里是不行的。在 fragment 里需要创建一个单独的 view，并返回。用 with 语句来创建这样一个单独的 view。<br>在 vertial layout 里添加了一个 textview。<br>上面一步创建的 textview 作为 list view 没有数据的时候显示的 empty view 来使用。<br>第二个 tab，DetailFragment<br>日记的内容包括，日记 title，日记本身的内容还有日记的日期。</p>
<p>所以布局上就包括日记的 title 内容输入用的 EditText 以及为了说明用的 text view，还有 edit text 里的 hint。最后还有一个选择<br>日期的控件。</p>
<pre><code>return with(ctx) {
    verticalLayout {
        padding = dip(10)
        backgroundColor = Color.WHITE
        textView(&quot;TITLE&quot;) {

        }.lparams(width = matchParent)

        titleEditText = editText {
            hint = currentDateString()
            lines = 1
        }.lparams(width = matchParent) {
            topMargin = dip(5)
        }

        textView(&quot;CONTENT&quot;) {

        }.lparams(width = matchParent) {
            topMargin = dip(15)
        }

        contentEditText = editText {
            hint = &quot;what&apos;s going on...&quot;
            setHorizontallyScrolling(false)
        }.lparams(width = matchParent) {
            //                    height = matchParent
            topMargin = dip(5)
        }

        button(R.string.button_select_time) {
            gravity = Gravity.CENTER
            onClick {
                val fm = activity.supportFragmentManager
                var datePicker = DatePickerFragment.newInstance(diaryModel?.date)
                datePicker.setTargetFragment(this@DetailFragment, DetailFragment.REQUEST_DATE)
                datePicker.show(fm, &quot;date&quot;)
            }
        }
        // *
        button(R.string.button_detail_ok) {
            onClick {
                v -&gt;
                println(&quot;ok button clicked&quot;)
                try {
                    var model = diaryModel!!
                    model.title = titleEditText?.text.toString()
                    model.content = contentEditText?.text.toString()
                    AnkoApplication.diaryDataSource.add(model)

                    modelChangeListener?.modelChanged()

                    toast(R.string.model_saved_ok)
                } catch(e: Exception) {
                    Log.d(&quot;##DetailFragment&quot;, &quot;error: ${e.toString()}&quot;)
                    toast(R.string.model_save_error)
                }
            }
        }.lparams {
            topMargin = dip(10)
            width = matchParent
        }
    }.style {
        view -&gt;
        when (view) {
            is Button -&gt; {
                view.gravity = Gravity.CENTER
            }
            is TextView -&gt; {
                view.gravity = Gravity.LEFT
                view.textSize = 20f
                view.textColor = Color.DKGRAY
            }
        }
    }
}
</code></pre><p>需要注意打星号的地方。按钮在点击之后会弹出一个 dialog fragment 来显示日期 view。用户可以在这个日期 view 里选择相应的日期。但是，如何从日期 dialog fragment 传递选择的日期给 DetailFragment 呢？这里就涉及到两个 fragment 之间传递数据的问题。</p>
<p>选择日期的dialog fragment是DatePickerFragment。</p>
<pre><code>var pickerView = DatePicker(activity)
pickerView.calendarViewShown = false
pickerView.layoutParams = ViewGroup.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT,
        ViewGroup.LayoutParams.WRAP_CONTENT)
pickerView.init(year, month, day) {
    view, year, month, day -&gt;
    mDate = GregorianCalendar(year, month, day).time

    arguments.putSerializable(EXTRA_DATE, mDate)
}

return AlertDialog.Builder(activity)
        .setView(pickerView)
        .setTitle(R.string.date_picker_title)
        .setPositiveButton(R.string.picker_button_ok) { dialog, which -&gt;
            toast(&quot;hello world!&quot;)
            sendResult(Activity.RESULT_OK)
        }.create()
</code></pre><p>首先 DatePickerFragment 要继承 DialogFragment 之后 override 方法 onCreateDialog(savedInstanceState: Bundle)。 在这个方法里使用上面代码创建一个包含日期选择器的 dialog。</p>
<p>在选择日期的时候，会触发 DatePicker 的 OnDateChangedListener 接口的 onDateChanged 方法。我们在这个方法里记录选择好的日期数据，在dialog的positive按钮点击之后把这个数据发送给 DetailFragment。</p>
<p>那么怎么发送呢？使用 target fargment 方法。在 detail fragment 弹出 dialog fragment 的时候，把 detail fragment 设置为 target fragment。</p>
<pre><code>button(R.string.button_select_time) {
    gravity = Gravity.CENTER
    onClick {
        val fm = activity.supportFragmentManager
        var datePicker = DatePickerFragment.newInstance(diaryModel?.date)
        // *
        datePicker.setTargetFragment(this@DetailFragment, DetailFragment.REQUEST_DATE)
        datePicker.show(fm, &quot;date&quot;)
    }
}
</code></pre><p>在标星下面的一行代码中。datePicker.setTargetFragment(this@DetailFragment,DetailFragment.REQUEST_DATE)将DetailFragment设定为target fragment，并且指定REQUEST_DATE这code，为以后取出数据使用。</p>
<pre><code>companion object Factory {
    val REQUEST_DATE = 0`
}
</code></pre><p>在 positive 按钮点击之后执行方法 sendResult 回传数据</p>
<pre><code>private fun sendResult(resultCode: Int) {
    if (targetFragment == null)
        return

    var i = Intent()
    i.putExtra(EXTRA_DATE, mDate)
    // *
    targetFragment.onActivityResult(targetRequestCode, resultCode, i)
}
</code></pre><p>调用 targetFragment 的 onActivityResult() 方法来回传日期数据。</p>
<p>在 DetailFragment 中通过 override 方法 onActivityResult() 来接收数据。</p>
<pre><code>override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
    if (resultCode != Activity.RESULT_OK) {
        return
    }

    if (requestCode != REQUEST_DATE) {
        return
    }

    var date = data?.getSerializableExtra(DatePickerFragment.EXTRA_DATE) as Date
    diaryModel?.date = date
}
</code></pre><p>日期数据传输这部分到这里结束。</p>
<p>全文也可以在这里画上一个句点了。以上还有很多关于 Anko 没有使用的地方。Anko 也是可以实现代码界面分离的。继承 AnkoComponent 可以写出独立的布局文件，并且可以用 anko preview 插件来预览界面效果。就拿 setting 这个 tab 的 fragment 来举例：<br>首先定义一个独立的布局文件:</p>
<pre><code>class SettingsUI&lt;T&gt; : AnkoComponent&lt;T&gt; {
    override fun createView(ui: AnkoContext&lt;T&gt;) = with(ui) {
        verticalLayout {
            backgroundColor = ContextCompat.getColor(ctx, R.color.SnowWhite)
            textView { text = resources.getString(R.string.settings_title) }

            button(&quot;activity with the same `AnkoComponent`&quot;) {
                id = ID_BUTTON
            }
        }
    }

    companion object Factory {
        public val ID_BUTTON = 101
    }
}
</code></pre><p>把这个布局文件用在 DiarySettingsFragment 上：</p>
<pre><code>override fun onCreateView(inflater: LayoutInflater?, container: ViewGroup?,
    val view = SettingsUI&lt;DiarySettingsFragment&gt;().createView(AnkoContext.create(ctx, DiarySettingsFragment()))

    return view
}
</code></pre><p>然后这个布局还可以用在我们刚刚创建的 TempActivity 上：</p>
<pre><code>override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    SettingsUI&lt;TempActivity&gt;().setContentView(this)

    val button = find&lt;Button&gt;(SettingsUI.ID_BUTTON)
    button.text = &quot;you are in `TempActivity`, CLICK!&quot;

    button.onClick {
        toast(&quot;${TempActivity::class.java.simpleName}&quot;)
    }
}
</code></pre><p>Activity 上使用就简单很多了，只需要这么一句 SettingsUI<tempactivity>().setContentView(this)。</tempactivity></p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://hellokk.cc/2018/06/05/Kotlin 中使用 Anko 编写布局/" data-id="cjtcfau5200078t0po6ulmepr" class="article-share-link" data-share="baidu" data-title="Kotlin 中使用 Anko 编写布局">分享到</a>
      

      
        <a href="http://hellokk.cc/2018/06/05/Kotlin 中使用 Anko 编写布局/#ds-thread" class="article-comment-link">评论</a>
      

      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/06/05/使用观察者模式进行订单管理/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">
        
          使用观察者模式进行订单管理
        
      </div>
    </a>
  
  
    <a href="/2018/05/21/响应式函数编程 RxJava & RxAndroid /" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">响应式函数编程 RxJava &amp; RxAndroid</div>
    </a>
  
</nav>

  
</article>


  <section id="comments">
    <div id="ds-thread" class="ds-thread" data-thread-key="2018/06/05/Kotlin 中使用 Anko 编写布局/" data-title="Kotlin 中使用 Anko 编写布局" data-url="http://hellokk.cc/2018/06/05/Kotlin 中使用 Anko 编写布局/"></div>
  </section>
</section>
      
      <aside id="sidebar">
  
    
  
    
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">六月 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a><span class="archive-list-count">2</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">近期文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/07/25/仿微信剪切视频时长View/">仿微信剪切视频时长View</a>
          </li>
        
          <li>
            <a href="/2018/06/05/使用观察者模式进行订单管理/">使用观察者模式进行订单管理</a>
          </li>
        
          <li>
            <a href="/2018/06/05/Kotlin 中使用 Anko 编写布局/">Kotlin 中使用 Anko 编写布局</a>
          </li>
        
          <li>
            <a href="/2018/05/21/响应式函数编程 RxJava & RxAndroid /">响应式函数编程 RxJava &amp; RxAndroid</a>
          </li>
        
          <li>
            <a href="/2017/11/19/仿QQ空间打赏功能实现/">仿QQ空间打赏功能实现</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">友情链接</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="http://arvinxiang.com" target="_blank">主题作者</a>
          </li>
        
          <li>
            <a href="http://reqianduan.com" target="_blank">热前端</a>
          </li>
        
          <li>
            <a href="http://yuancheng.work" target="_blank">远程.work</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
      
    </div>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 青宁<br>
      Powered by <a href="//hexo.io/" target="_blank">Hexo</a>
      .
      Theme by <a href="https://github.com/xiangming/landscape-plus" target="_blank">Landscape-plus</a>
    </div>
  </div>
</footer>
  </div>
  <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
  <!-- totop start -->
<div id="totop">
<a title="返回顶部"><img src="/img/scrollup.png"/></a>
</div>

<!-- totop end -->

<!-- 多说公共js代码 start -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"reqianduan"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共js代码 end -->


<!-- 百度分享 start -->

<div id="article-share-box" class="article-share-box">
  <div id="bdshare" class="bdsharebuttonbox article-share-links">
    <a class="article-share-weibo" data-cmd="tsina" title="分享到新浪微博"></a>
    <a class="article-share-weixin" data-cmd="weixin" title="分享到微信"></a>
    <a class="article-share-qq" data-cmd="sqq" title="分享到QQ"></a>
    <a class="article-share-renren" data-cmd="renren" title="分享到人人网"></a>
    <a class="article-share-more" data-cmd="more" title="更多"></a>
  </div>
</div>
<script>
  function SetShareData(cmd, config) {
    if (shareDataTitle && shareDataUrl) {
      config.bdText = shareDataTitle;
      config.bdUrl = shareDataUrl;
    }
    return config;
  }
  window._bd_share_config={
    "common":{onBeforeClick: SetShareData},
    "share":{"bdCustomStyle":"/css/bdshare.css"}
  };
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='//bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

<!-- 百度分享 end -->

<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>




<script src="/js/script.js"></script>

</div>
</body>
</html>
